; @module Motor
; @device E,P,S
; Wheel, copyright (c) 2017 - present by Arno van der Vegt
; Distributed under an MIT license: https://arnovandervegt.github.io/wheel/license.txt

; @description
; This file contains procedures to control `EV3` or `Powered Up` motors.

; @const The motor module.
#define MODULE_MOTOR          6     ; `image:images/ev3/motorMedium64.png`

; @const Module calls to control the motors.
#define MOTOR_SET_TYPE        0
#define MOTOR_SET_SPEED       1
#define MOTOR_SET_BRAKE       2
#define MOTOR_GET_TYPE        3
#define MOTOR_RESET           4
#define MOTOR_REVERSE         5
#define MOTOR_MOVE_TO         6
#define MOTOR_MOVE_TO_BITS    7
#define MOTOR_ON              8
#define MOTOR_TIME_ON         9
#define MOTOR_STOP           10
#define MOTOR_READ           11
#define MOTOR_READY          12
#define MOTOR_READY_BITS     13
#define MOTOR_THRESHOLD      14

; @const Motor types.
#define MOTOR_MEDIUM          7
#define MOTOR_LARGE           8

; @const The motor outputs.
#define OUTPUT_A              0
#define OUTPUT_B              1
#define OUTPUT_C              2
#define OUTPUT_D              3

; @const Bits to identify the motor combinations for ready or to move multiple motors to a given position.
#define MOTOR_BITS_A    0b0001
#define MOTOR_BITS_B    0b0010
#define MOTOR_BITS_AB   0b0011
#define MOTOR_BITS_C    0b0100
#define MOTOR_BITS_AC   0b0101
#define MOTOR_BITS_BC   0b0110
#define MOTOR_BITS_ABC  0b0111
#define MOTOR_BITS_D    0b1000
#define MOTOR_BITS_AD   0b1001
#define MOTOR_BITS_BD   0b1010
#define MOTOR_BITS_ABD  0b1011
#define MOTOR_BITS_CD   0b1100
#define MOTOR_BITS_ACD  0b1101
#define MOTOR_BITS_BCD  0b1110
#define MOTOR_BITS_ABCD 0b1111

; @const Brake or coast the motor.
#define MOTOR_COAST           0
#define MOTOR_BRAKE           1

; @proc             Set the motor type.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param type       The type of motor: `MOTOR_MEDIUM` or `MOTOR_LARGE`.
proc motorLayerSetType(number layer, number id, number type)
    addr layer
    mod  MODULE_MOTOR, MOTOR_SET_TYPE
end

; @proc             Set the motor speed.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param speed      The speed of the motor. The value must be between -100 and 100 where negative values mean a reverse direction.
proc motorLayerSetSpeed(number layer, number id, number speed)
    addr layer
    mod  MODULE_MOTOR, MOTOR_SET_SPEED
end

; @proc             Set the motor brake or coast: 0 = coast, 1 = brake. The default value is 1 (brake).
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerSetBrake(number layer, number id, number brake)
    addr layer
    mod  MODULE_MOTOR, MOTOR_SET_BRAKE
end

; @proc             Get the connected motor type.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerGetType(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_GET_TYPE
end

; @proc             Reset the tacho count for the motor.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerReset(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_RESET
end

; @proc             Reverse the motor move to direction.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerReverse(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_REVERSE
end

; @proc             Move the motor to a given target angle.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param target     The target angle.
proc motorLayerMoveTo(number layer, number id, number target)
    addr layer
    mod  MODULE_MOTOR, MOTOR_MOVE_TO
end

; @proc             Move the motor to a given target angle.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param bits       The motor bits, the first bit is motor A, the second motor B, etc. Checking motor A and C: 0b0101
; @param target     The target angle.
proc motorLayerMoveToBits(number layer, number bits, number target)
    addr layer
    mod  MODULE_MOTOR, MOTOR_MOVE_TO_BITS
end

; @proc             Turn the motor on.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerOn(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_ON
end

; @proc             Turn the motor on for a given time.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param time       Time in milliseconds.
proc motorLayerTimeOn(number layer, number id, number time)
    addr layer
    mod  MODULE_MOTOR, MOTOR_TIME_ON
end

; @proc             Stop the motor.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerStop(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_STOP
end

; @proc             Read a motor position.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @return           The current motor position in degrees.
proc motorLayerRead(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_READ
end

; @proc             Check if a motor reached its target.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorLayerReady(number layer, number id)
    addr layer
    mod  MODULE_MOTOR, MOTOR_READY
end

; @proc             Check if one or more motors reached their target.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param bits       The motor bits, the first bit is motor A, the second motor B, etc. Checking motor A and C: 0b0101
proc motorLayerReadyBits(number layer, number bits)
    addr layer
    mod  MODULE_MOTOR, MOTOR_READY_BITS
end

; @proc             Set the threshold for the motor to reach the given angle, this proc only applies to Powered Up.
; @param layer      The layer, the daisy chained device. 0 is the primary brick.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param threshold  The threshold, if the difference in degrees between the motor target and position is less
;                   than this value then the motor ready status returns `TRUE`.
proc motorLayerThreshold(number layer, number id, number threshold)
    addr layer
    mod  MODULE_MOTOR, MOTOR_THRESHOLD
end

; @proc             Set the motor type for the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param type       The type of motor: `MOTOR_MEDIUM` or `MOTOR_LARGE`.
proc motorSetType(number id, number type)
    motorLayerSetType(0, id, type)
end

; @proc             Set the motor speed for the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param speed      The speed of the motor. The value must be between -100 and 100 where negative values mean a reverse direction.
proc motorSetSpeed(number id, number speed)
    motorLayerSetSpeed(0, id, speed)
end

; @proc             Set the motor brake or coast for the main device: 0 = coast, 1 = brake. The default value is 1 (brake).
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorSetBrake(number id, number brake)
    motorLayerSetBrake(0, id, brake)
end

; @proc             Get the connected motor type.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @return           The type of motor connected to the primary device.
proc motorGetType(number id)
    ret motorLayerGetType(0, id)
end

; @proc             Reset the tacho count for the motor for the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorReset(number id)
    motorLayerReset(0, id)
end

; @proc             Reverse the motor move to direction.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorReverse(number layer, number id)
    motorLayerReverse(0, id)
end

; @proc             Move the motor to a given target angle for the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param target     The target angle.
proc motorMoveTo(number id, number target)
    motorLayerMoveTo(0, id, target)
end

; @proc             Move the motor to a given target angle.
; @param bits       The motor bits, the first bit is motor A, the second motor B, etc. Checking motor A and C: 0b0101
; @param target     The target angle.
proc motorMoveToBits(number bits, number target)
    motorLayerMoveToBits(0, bits, target)
end

; @proc             Turn the motor of the main device on.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorOn(number id)
    motorLayerOn(0, id)
end

; @proc             Turn the motor of the main device on for a given time.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param time       Time in milliseconds.
proc motorTimeOn(number id, number time)
    motorLayerTimeOn(0, id, time)
end

; @proc             Stop the motor on the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorStop(number id)
    motorLayerStop(0, id)
end

; @proc             Read a motor position on the main device.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @return           The current motor position in degrees.
proc motorRead(number id)
    ret motorLayerRead(0, id)
end

; @proc             Check if a motor on the main device reached its target.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
proc motorReady(number id)
    ret motorLayerReady(0, id)
end

; @proc             Check if one or more motors reached their target.
; @param bits       The motor bits, the first bit is motor A, the second motor B, etc. Checking motor A and C: 0b0101
proc motorReadyBits(number bits)
    ret motorLayerReadyBits(0, bits)
end

; @device P
; @proc             Set the threshold for the motor to reach the given angle, this proc only applies to Powered Up.
; @param id         The output, the first output is 0. Constants: `OUTPUT_A`, `OUTPUT_B`, `OUTPUT_C`, `OUTPUT_D`.
; @param threshold  The threshold, if the difference in degrees between the motor target and position is less
;                   than this value then the motor ready status returns `TRUE`.
proc motorThreshold(number id, number threshold)
    motorLayerThreshold(0, id, threshold)
end

; @proc             Wait until the given motors have reached their targets.
; @param bits       The motor bits, the first bit is motor A, the second motor B, etc. Checking motor A and C: 0b0101
proc waitForMotors(number bits)
    while motorReadyBits(bits) == 0
    end
end
