//=================================================================================================//
//
// File: vm/vmVars.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
HANDLE gFile_H                                                          // Handle to program file
HANDLE gHeap_H                                                          // Heap memory
HANDLE gString_H                                                        // A temp string buffer for a single string
HANDLE gStrings_H                                                       // A buffer to hold all string data
DATA32 gStringMaxLength_32                                              // The maximum string length
DATA32 gStringMaxCount_32                                               // The maximum number of strings
DATA32 gStringDataSize_32                                               // The data size needed to store one string
DATA16 gStringCount_16                                                  // The current number of strings in use
DATA8  gLayerCount_8                                                    // Number of connected extra EV3 devices
DATA32 gCommandCount_32                                                 // The number of commands in the program
HANDLE gCommandList_H                                                   // 8 Bit commands and parameter type info
DATA32 gCommandListOffset_32
HANDLE gCommandParam_H                                                  // Float command parameter values
DATA32 gCommandParamOffset_32
DATA8  gCommand_8                                                       // 8 Bit command
DATA8  gType1_8                                                         // 8 Bit parameter 1 type
DATA8  gType2_8                                                         // 8 Bit parameter 2 type
DATAF  gParam1_F                                                        // Float parameter 1 value, constant/local/global/pointer
DATAF  gParam2_F                                                        // Float parameter 2 value, constant/local/global/pointer
DATAF  gParam1Value_F                                                   // Float, actual parameter 1 value
DATAF  gParam2Value_F                                                   // Float, actual parameter 2 value
DATA8  gKeepRet_8
HANDLE gFiles_H                                                         // List of file modes and filenames
HANDLE gDeviceList_H 													// Array with device info

//=================================================================================================//
//
// File: vm/modScreenVars.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
DATA8  gModScreenFill_8                                                 // Boolean, use fill for drawing
DATA8  gModScreenFillColor_8                                            // Fill color, 0=WHITE, 1=BLACK
DATA8  gModScreenTextSize_8                                             // Text align, 0=SMALL, 1=MEDIUM, 2=LARGE
DATA8  gModScreenTextAlign_8                                            // Text align, 0=LEFT, 1=CENTER, 2=RIGHT
DATA16 gModScreenCharSize_16                                            // Character size
DATA8  gModScreenUpdated_8
DATA32 gModScreenUpdateTime_32

//=================================================================================================//
//
// File: vm/modMotorVars.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//

//== LAYER 1 ======================================================================================//

DATA8  gModMotor1AStarted_8
DATA8  gModMotor1AMode_8
DATA8  gModMotor1AReady_8
DATA8  gModMotor1ASpeed_8
DATA8  gModMotor1ABrake_8
DATA32 gModMotor1ACurrrent_32
DATA32 gModMotor1ATarget_32
DATA32 gModMotor1ATime_32

DATA8  gModMotor1BStarted_8
DATA8  gModMotor1BMode_8
DATA8  gModMotor1BReady_8
DATA8  gModMotor1BSpeed_8
DATA8  gModMotor1BBrake_8
DATA32 gModMotor1BCurrrent_32
DATA32 gModMotor1BTarget_32
DATA32 gModMotor1BTime_32

DATA8  gModMotor1CStarted_8
DATA8  gModMotor1CMode_8
DATA8  gModMotor1CReady_8
DATA8  gModMotor1CSpeed_8
DATA8  gModMotor1CBrake_8
DATA32 gModMotor1CCurrrent_32
DATA32 gModMotor1CTarget_32
DATA32 gModMotor1CTime_32

DATA8  gModMotor1DStarted_8
DATA8  gModMotor1DMode_8
DATA8  gModMotor1DReady_8
DATA8  gModMotor1DSpeed_8
DATA8  gModMotor1DBrake_8
DATA32 gModMotor1DCurrrent_32
DATA32 gModMotor1DTarget_32
DATA32 gModMotor1DTime_32

//== LAYER 2 ======================================================================================//

DATA8  gModMotor2AStarted_8
DATA8  gModMotor2AMode_8
DATA8  gModMotor2AReady_8
DATA8  gModMotor2ASpeed_8
DATA8  gModMotor2ABrake_8
DATA32 gModMotor2ACurrrent_32
DATA32 gModMotor2ATarget_32
DATA32 gModMotor2ATime_32

DATA8  gModMotor2BStarted_8
DATA8  gModMotor2BMode_8
DATA8  gModMotor2BReady_8
DATA8  gModMotor2BSpeed_8
DATA8  gModMotor2BBrake_8
DATA32 gModMotor2BCurrrent_32
DATA32 gModMotor2BTarget_32
DATA32 gModMotor2BTime_32

DATA8  gModMotor2CStarted_8
DATA8  gModMotor2CMode_8
DATA8  gModMotor2CReady_8
DATA8  gModMotor2CSpeed_8
DATA8  gModMotor2CBrake_8
DATA32 gModMotor2CCurrrent_32
DATA32 gModMotor2CTarget_32
DATA32 gModMotor2CTime_32

DATA8  gModMotor2DStarted_8
DATA8  gModMotor2DMode_8
DATA8  gModMotor2DReady_8
DATA8  gModMotor2DSpeed_8
DATA8  gModMotor2DBrake_8
DATA32 gModMotor2DCurrrent_32
DATA32 gModMotor2DTarget_32
DATA32 gModMotor2DTime_32

//== LAYER 3 ======================================================================================//

DATA8  gModMotor3AStarted_8
DATA8  gModMotor3AMode_8
DATA8  gModMotor3AReady_8
DATA8  gModMotor3ASpeed_8
DATA8  gModMotor3ABrake_8
DATA32 gModMotor3ACurrrent_32
DATA32 gModMotor3ATarget_32
DATA32 gModMotor3ATime_32

DATA8  gModMotor3BStarted_8
DATA8  gModMotor3BMode_8
DATA8  gModMotor3BReady_8
DATA8  gModMotor3BSpeed_8
DATA8  gModMotor3BBrake_8
DATA32 gModMotor3BCurrrent_32
DATA32 gModMotor3BTarget_32
DATA32 gModMotor3BTime_32

DATA8  gModMotor3CStarted_8
DATA8  gModMotor3CMode_8
DATA8  gModMotor3CReady_8
DATA8  gModMotor3CSpeed_8
DATA8  gModMotor3CBrake_8
DATA32 gModMotor3CCurrrent_32
DATA32 gModMotor3CTarget_32
DATA32 gModMotor3CTime_32

DATA8  gModMotor3DStarted_8
DATA8  gModMotor3DMode_8
DATA8  gModMotor3DReady_8
DATA8  gModMotor3DSpeed_8
DATA8  gModMotor3DBrake_8
DATA32 gModMotor3DCurrrent_32
DATA32 gModMotor3DTarget_32
DATA32 gModMotor3DTime_32

//== LAYER 4 ======================================================================================//

DATA8  gModMotor4AStarted_8
DATA8  gModMotor4AMode_8
DATA8  gModMotor4AReady_8
DATA8  gModMotor4ASpeed_8
DATA8  gModMotor4ABrake_8
DATA32 gModMotor4ACurrrent_32
DATA32 gModMotor4ATarget_32
DATA32 gModMotor4ATime_32

DATA8  gModMotor4BStarted_8
DATA8  gModMotor4BMode_8
DATA8  gModMotor4BReady_8
DATA8  gModMotor4BSpeed_8
DATA8  gModMotor4BBrake_8
DATA32 gModMotor4BCurrrent_32
DATA32 gModMotor4BTarget_32
DATA32 gModMotor4BTime_32

DATA8  gModMotor4CStarted_8
DATA8  gModMotor4CMode_8
DATA8  gModMotor4CReady_8
DATA8  gModMotor4CSpeed_8
DATA8  gModMotor4CBrake_8
DATA32 gModMotor4CCurrrent_32
DATA32 gModMotor4CTarget_32
DATA32 gModMotor4CTime_32

DATA8  gModMotor4DStarted_8
DATA8  gModMotor4DMode_8
DATA8  gModMotor4DReady_8
DATA8  gModMotor4DSpeed_8
DATA8  gModMotor4DBrake_8
DATA32 gModMotor4DCurrrent_32
DATA32 gModMotor4DTarget_32
DATA32 gModMotor4DTime_32

//=================================================================================================//
//
// File: vm/modSensorVars.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
HANDLE gModSensorType_H                                                 // Sensor types for all layers/sensors
HANDLE gModSensorMode_H                                                 // Sensor modes for all layers/sensors

//=================================================================================================//
//
// File: vm/vm.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
vmthread MAIN {
    MOVE8_8(0, gKeepRet_8)

    CALL(modScreenInit)
    CALL(modSensorInit)
    CALL(modFileInit)
    CALL(modMotorInit)
    CALL(load)
    CALL(run)
}

//= Threads device 1 ==============================================================================//

vmthread OBJECT2 {
    CALL(modMotor1AUpdate)
}
vmthread OBJECT3 {
    CALL(modMotor1BUpdate)
}
vmthread OBJECT4 {
    CALL(modMotor1CUpdate)
}
vmthread OBJECT5 {
    CALL(modMotor1DUpdate)
}

//= Threads device 2 ==============================================================================//

vmthread OBJECT6 {
    CALL(modMotor2AUpdate)
}
vmthread OBJECT7 {
    CALL(modMotor2BUpdate)
}
vmthread OBJECT8 {
    CALL(modMotor2CUpdate)
}
vmthread OBJECT9 {
    CALL(modMotor2DUpdate)
}

//= Threads device 3 ==============================================================================//

vmthread OBJECT10 {
    CALL(modMotor3AUpdate)
}
vmthread OBJECT11 {
    CALL(modMotor3BUpdate)
}
vmthread OBJECT12 {
    CALL(modMotor3CUpdate)
}
vmthread OBJECT13 {
    CALL(modMotor3DUpdate)
}

//= Threads device 4 ==============================================================================//

vmthread OBJECT14 {
    CALL(modMotor4AUpdate)
}
vmthread OBJECT15 {
    CALL(modMotor4BUpdate)
}
vmthread OBJECT16 {
    CALL(modMotor4CUpdate)
}
vmthread OBJECT17 {
    CALL(modMotor4DUpdate)
}

//= Device 1 ======================================================================================//

subcall startThread1A {
    JR_NEQ8(gModMotor1AStarted_8, 0, motor_a1_started)
    MOVE8_8(1, gModMotor1AStarted_8)
    OBJECT_START(2)
motor_a1_started:
}
subcall startThread1B {
    JR_NEQ8(gModMotor1BStarted_8, 0, motor_b1_started)
    MOVE8_8(1, gModMotor1BStarted_8)
    OBJECT_START(3)
motor_b1_started:
}
subcall startThread1C {
    JR_NEQ8(gModMotor1CStarted_8, 0, motor_c1_started)
    MOVE8_8(1, gModMotor1CStarted_8)
    OBJECT_START(4)
motor_c1_started:
}
subcall startThread1D {
    JR_NEQ8(gModMotor1DStarted_8, 0, motor_d1_started)
    MOVE8_8(1, gModMotor1DStarted_8)
    OBJECT_START(5)
motor_d1_started:
}

//= Device 2 ======================================================================================//

subcall startThread2A {
    JR_NEQ8(gModMotor2AStarted_8, 0, motor_a2_started)
    MOVE8_8(1, gModMotor2AStarted_8)
    OBJECT_START(6)
motor_a2_started:
}
subcall startThread2B {
    JR_NEQ8(gModMotor2BStarted_8, 0, motor_b2_started)
    MOVE8_8(1, gModMotor2BStarted_8)
    OBJECT_START(7)
motor_b2_started:
}
subcall startThread2C {
    JR_NEQ8(gModMotor2CStarted_8, 0, motor_c2_started)
    MOVE8_8(1, gModMotor2CStarted_8)
    OBJECT_START(8)
motor_c2_started:
}
subcall startThread2D {
    JR_NEQ8(gModMotor2DStarted_8, 0, motor_d2_started)
    MOVE8_8(1, gModMotor2DStarted_8)
    OBJECT_START(9)
motor_d2_started:
}

//= Device 3 ======================================================================================//

subcall startThread3A {
    JR_NEQ8(gModMotor3AStarted_8, 0, motor_a3_started)
    MOVE8_8(1, gModMotor3AStarted_8)
    OBJECT_START(10)
motor_a3_started:
}
subcall startThread3B {
    JR_NEQ8(gModMotor3BStarted_8, 0, motor_b3_started)
    MOVE8_8(1, gModMotor3BStarted_8)
    OBJECT_START(11)
motor_b3_started:
}
subcall startThread3C {
    JR_NEQ8(gModMotor3CStarted_8, 0, motor_c3_started)
    MOVE8_8(1, gModMotor3CStarted_8)
    OBJECT_START(12)
motor_c3_started:
}
subcall startThread3D {
    JR_NEQ8(gModMotor3DStarted_8, 0, motor_d3_started)
    MOVE8_8(1, gModMotor3DStarted_8)
    OBJECT_START(13)
motor_d3_started:
}

//= Device 4 ======================================================================================//

subcall startThread4A {
    JR_NEQ8(gModMotor4AStarted_8, 0, motor_a4_started)
    MOVE8_8(1, gModMotor4AStarted_8)
    OBJECT_START(14)
motor_a4_started:
}
subcall startThread4B {
    JR_NEQ8(gModMotor4BStarted_8, 0, motor_b4_started)
    MOVE8_8(1, gModMotor4BStarted_8)
    OBJECT_START(15)
motor_b4_started:
}
subcall startThread4C {
    JR_NEQ8(gModMotor4CStarted_8, 0, motor_c4_started)
    MOVE8_8(1, gModMotor4CStarted_8)
    OBJECT_START(16)
motor_c4_started:
}
subcall startThread4D {
    JR_NEQ8(gModMotor4DStarted_8, 0, motor_d4_started)
    MOVE8_8(1, gModMotor4DStarted_8)
    OBJECT_START(17)
motor_d4_started:
}

//=================================================================================================//
//
// File: vm/vmLoad.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall load {
    DATA32 lFileSize_32
    FILE(OPEN_READ, 'program.rtf', gFile_H, lFileSize_32)

    CALL(loadS)                                                         // Wheel VM Program
    CALL(loadS)                                                         // #VERSION
    CALL(loadS)                                                         // #VERSION, NUMBER
    CALL(loadS)                                                         // #NAME
    CALL(loadS)                                                         // #NAME, NAME
    CALL(loadS)                                                         // #LAYERS
    CALL(load8, gLayerCount_8, 0x03)                                    // #LAYERS, NUMBER

    DATA32 lHeapSize_32
    CALL(loadS)                                                         // #HEAP
    CALL(load32, lHeapSize_32, 0x03)
    ARRAY(CREATEF, lHeapSize_32, gHeap_H)                               // Allocate the heap

    CALL(loadStrings)
    CALL(loadConstants)

    DATA32 lRegCode_32
    CALL(loadS)                                                         // #REG_CODE
    CALL(load32, lRegCode_32, 0x03)
    CALL(writeMem32, 4, 0, lRegCode_32)                                 // Write code register at heap offset 4

    DATA32 lRegStack_32
    CALL(loadS)                                                         // #REG_STACK
    CALL(load32, lRegStack_32, 0x03)
    CALL(writeMem32, 0, 0, lRegStack_32)                                // Write stack register at heap offset 0

    CALL(loadCommands)

    FILE(CLOSE, gFile_H)
}

subcall loadCommands {
    DATA32 lCommandIndex_32
    DATA16 lCommand_16
    DATA16 lType1_16
    DATA16 lType2_16
    DATA32 lSize_32

    CALL(loadS)                                                         // #COMMANDS
    CALL(load32, gCommandCount_32, 0x03)

    MUL32(gCommandCount_32, 3, lSize_32)                                // Command and param info = gCommandCount_32 * 3
    ARRAY(CREATE8, lSize_32, gCommandList_H)
    MOVE16_16(0, gCommandListOffset_32)

    MUL32(gCommandCount_32, 2, lSize_32)                                // Command and param values = gCommandCount_32 * 2
    ARRAY(CREATEF, lSize_32, gCommandParam_H)
    ARRAY(RESIZE, gCommandParam_H, lSize_32)
    MOVE32_32(0, gCommandParamOffset_32)

    MOVE32_32(0, lCommandIndex_32)                                      // lCommandIndex_32 = 0
read_command:
    CALL(load16, lCommand_16, 0x05)                                     // Read command with comma delimiter, param type1, param type2
    CALL(loadF, gParam1_F, 0x05)                                        // Read param value1 with comma delimiter
    CALL(loadF, gParam2_F, 0x03)                                        // Read param value2 with return delimiter

    CALL(storeCommandParam, gParam1_F)
    CALL(storeCommandParam, gParam2_F)

    MOVE16_16(lCommand_16, lType1_16)
    MOVE16_16(lCommand_16, lType2_16)

    DIV16(lCommand_16, 0x10, lCommand_16)
    AND16(lCommand_16, 0x0F, lCommand_16)
    MOVE16_8(lCommand_16, gCommand_8)                                   // gCommand_8 = (lCommand_16 >> 4) && 15

    AND16(lType2_16, 0x03, lType2_16)
    MOVE16_8(lType2_16, gType2_8)                                       // gType2_8 = lType2_16 & 3

    DIV16(lType1_16, 0x04, lType1_16)
    AND16(lType1_16, 0x03, lType1_16)
    MOVE16_8(lType1_16, gType1_8)                                       // gType1_8 = (lType1_16 >> 2) & 3

    CALL(storeCommandList, gCommand_8)
    CALL(storeCommandList, gType1_8)
    CALL(storeCommandList, gType2_8)

    ADD32(lCommandIndex_32, 1, lCommandIndex_32)                        // lCommandIndex_32 = lCommandIndex_32 + 1
    JR_LT32(lCommandIndex_32, gCommandCount_32, read_command)           // Jump to read_command if there are more...
}

subcall loadStrings {
    DATA8  lString_H
    DATA16 lStringCount_16
    DATA16 lStingCount_16
    DATA8  lStingLength_8
    DATA32 lStringBufferSize_32

    CALL(loadS)                                                         // #STRINGS
    CALL(load32, gStringMaxLength_32, 0x05)                             // Load the string length, comma delimiter
    CALL(load32, gStringMaxCount_32, 0x03)                              // Load the string count, return delimiter

    ADD32(gStringMaxLength_32, 1, gStringDataSize_32)
    MUL32(gStringDataSize_32, gStringMaxCount_32, lStringBufferSize_32)

    ARRAY(CREATE8, lStringBufferSize_32, gStrings_H)
    ARRAY(CREATE8, 127, gString_H)

    CALL(load16, gStringCount_16, 0x03)                                 // Load the number of strings
    JR_EQ16(gStringCount_16, 0, strings_done)                           // Jump to strings_done if gStringCount_16 = 0
    MOVE16_16(0, lStringCount_16)
load_string:
    FILE(READ_TEXT, gFile_H, 0x03, 64, @gString_H)
    CALL(writeString, lStringCount_16)
    ADD16(lStringCount_16, 1, lStringCount_16)
    JR_LT16(lStringCount_16, gStringCount_16, load_string)
strings_done:
}

subcall loadConstants {
    DATA16 lConstantCount_16
    DATA32 lConstantOffset_32
    DATA16 lConstantSize_16
    DATA16 lConstantIndex_16
    DATAF  lConstant_F
    CALL(loadS)                                                         // #CONSTANTS
    CALL(load16, lConstantCount_16, 0x03)
    JR_EQ16(lConstantCount_16, 0, constants_done)                       // Jump to constants_done if constantCount_16 = 0
load_constant:
    CALL(load32, lConstantOffset_32, 0x03)                              // Constant offset
    CALL(load16, lConstantSize_16, 0x03)
    JR_EQ16(lConstantSize_16, 1, load_one_constant_value)               // Jump if there is only one constant
    MOVE16_16(1, lConstantIndex_16)                                     // constantIndex16 = 1, Skip one, the last one has a return delimiter
load_constant_value:
    CALL(loadF, lConstant_F, 0x05)                                      // Read constant value with comma delimiter
    CALL(writeMemF, lConstantOffset_32, 0, lConstant_F)
    ADD32(lConstantOffset_32, 1, lConstantOffset_32)
    ADD16(lConstantIndex_16, 1, lConstantIndex_16)                      // constantIndex16 = constantIndex16 + 1
    JR_LT16(lConstantIndex_16, lConstantSize_16, load_constant_value)   // Jump to load_constant_value if there are more...
    SUB16(lConstantCount_16, 1, lConstantCount_16)                      // constantCount16 = constantCount16 - 1
    JR_NEQ16(lConstantCount_16, 0, load_constant)
load_one_constant_value:
    CALL(loadF, lConstant_F, 0x03)                                      // Read constant value with return delimiter
    CALL(writeMemF, lConstantOffset_32, 0, lConstant_F)
constants_done:
}

subcall storeCommandList {
    IN_8 pCommand_8
    ARRAY_WRITE(gCommandList_H, gCommandListOffset_32, pCommand_8)
    ADD32(gCommandListOffset_32, 1, gCommandListOffset_32)
}

subcall storeCommandParam {
    IN_F pParam_F
    ARRAY_WRITE(gCommandParam_H, gCommandParamOffset_32, pParam_F)
    ADD32(gCommandParamOffset_32, 1, gCommandParamOffset_32)
}

//=================================================================================================//

subcall load8 {
    OUT_8 pResult_8
    IN_8  pDelimiter_8
    DATAF lValue_F

    CALL(loadF, lValue_F, pDelimiter_8)
    MOVEF_8(lValue_F, pResult_8)
}

subcall load16 {
    OUT_16 pResult_16
    IN_8   pDelimiter_8
    DATAF  lValue_F

    CALL(loadF, lValue_F, pDelimiter_8)
    MOVEF_16(lValue_F, pResult_16)
}

subcall load32 {
    OUT_32 pResult_32
    IN_8   pDelimiter_8
    DATAF  lValue_F

    CALL(loadF, lValue_F, pDelimiter_8)
    MOVEF_32(lValue_F, pResult_32)
}

subcall loadF {
    OUT_F  pResult_F
    IN_8   pDelimiter_8
    HANDLE lString_H

    ARRAY(CREATE8, 32, lString_H)
    FILE(READ_TEXT, gFile_H, pDelimiter_8, 32, @lString_H)
    STRINGS(STRING_TO_VALUE, @lString_H, pResult_F)
    ARRAY(DELETE, lString_H)
}

subcall loadS {
    HANDLE lString_H

    ARRAY(CREATE8, 127, lString_H)
    FILE(READ_TEXT, gFile_H, 0x03, 32, @lString_H)
    ARRAY(DELETE, lString_H)
}

//=================================================================================================//
//
// File: vm/vmRun.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall run {
    DATA32 lRegCode_32
loop:
    CALL(readCommand)
    CALL(runCommand)
    CALL(readMem32, 4, 0, lRegCode_32)
    ADD32(lRegCode_32, 1, lRegCode_32)
    CALL(writeMem32, 4, 0, lRegCode_32)

    JR_EQ8(gModScreenUpdated_8, 0, screen_not_updated)                  // Check if the screen needs an update
    DATA32 lTime_32
    TIMER_READ(lTime_32)
    JR_LT32(lTime_32, gModScreenUpdateTime_32, screen_not_updated)
    UI_DRAW(UPDATE)                                                     // Update screen every 100ms
    MOVE32_32(lTime_32, gModScreenUpdateTime_32)
    ADD32(gModScreenUpdateTime_32, 100, gModScreenUpdateTime_32)
    MOVE8_8(0, gModScreenUpdated_8)
screen_not_updated:

    JR_LT32(lRegCode_32, gCommandCount_32, loop)
}

subcall runCommand {
    DATA8  lFlags_8
    DATA32 lRegCode_32
    DATA32 lRegStack_32
    DATA32 lRegPtr_32
    DATA32 lRegSrc_32
    DATA32 lRegDest_32
    DATA32 lRegStackNew_32
    DATA32 lParam1Offset_32
    DATA32 lParam2Offset_32

    CALL(readMem32, 0, 0, lRegStack_32)                                 // Read stack register from heap offset 0

    JR_EQ8(gType2_8, 2, param2_local)                                   // Param2 is local
    JR_EQ8(gType2_8, 1, param2_global)                                  // Param2 is global
    JR_EQ8(gType2_8, 3, param2_pointer)                                 // Param2 is pointer
    MOVEF_F(gParam2_F, gParam2Value_F)                                  // gParam2Value_F = gParam2_F
    JR(param2_fetched)
param2_global:
    MOVEF_32(gParam2_F, lParam2Offset_32)
    ARRAY_READ(gHeap_H, lParam2Offset_32, gParam2Value_F)               // gParam2Value_F = [#]
    JR(param2_fetched)
param2_pointer:
    MOVEF_32(gParam2_F, lParam2Offset_32)
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lParam2Offset_32, lRegPtr_32, lParam2Offset_32)
    ARRAY_READ(gHeap_H, lParam2Offset_32, gParam2Value_F)               // gParam2Value_F = [POINTER + #]
    JR(param2_fetched)
param2_local:
    MOVEF_32(gParam2_F, lParam2Offset_32)
    ADD32(lParam2Offset_32, lRegStack_32, lParam2Offset_32)
    ARRAY_READ(gHeap_H, lParam2Offset_32, gParam2Value_F)               // gParam2Value_F = [STACK + #]
param2_fetched:

    JR_GT8(gCommand_8, 4, cmd_operator)                                 // Operator: set, add, sub, mul...
    JR_LT8(gCommand_8, 2, cmd_call_ret)                                 // Call, ret...
    JR_EQ8(gCommand_8, 4, cmd_mod)                                      // Module
    JR_EQ8(gCommand_8, 3, cmd_jmpc)                                     // Jump conditional
    JR_EQ8(gCommand_8, 2, cmd_copy)                                     // Copy
    RETURN()

cmd_copy:
    JR_EQ8(gType1_8, 0, cmd_copy_param1_constant)                       // Param1 is constant
    JR_EQ8(gType1_8, 2, cmd_copy_param1_local)                          // Param1 is local
    JR_EQ8(gType1_8, 1, cmd_copy_param1_global)                         // Param1 is global
    JR_EQ8(gType1_8, 3, cmd_copy_param1_pointer)                        // Param1 is pointer
    RETURN()                                                            // INVALID!
cmd_copy_param1_constant:
    MOVEF_F(gParam1_F, gParam1Value_F)
    JR(cmd_copy_param1_done)
cmd_copy_param1_global:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_copy_param1_done)
cmd_copy_param1_pointer:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lParam1Offset_32, lRegPtr_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_copy_param1_done)
cmd_copy_param1_local:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ADD32(lParam1Offset_32, lRegStack_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
cmd_copy_param1_done:

    DATA16 lIndex_16
    DATA16 lCount_16
    DATAF  lValue_F
    CALL(readMem32, 1, 0, lRegSrc_32)
    CALL(readMem32, 2, 0, lRegDest_32)
    MOVEF_16(gParam1Value_F, lCount_16)
    MOVE16_16(0, lIndex_16)
cmd_copy_loop:
    ARRAY_READ(gHeap_H, lRegSrc_32, lValue_F)
    ARRAY_WRITE(gHeap_H, lRegDest_32, lValue_F)
    ADD32(lRegSrc_32, 1, lRegSrc_32)
    ADD32(lRegDest_32, 1, lRegDest_32)
    ADD16(lIndex_16, 1, lIndex_16)
    JR_LT16(lIndex_16, lCount_16, cmd_copy_loop)

    RETURN()

cmd_mod:
    DATA8  lMod_8                                                       // The module to call
    DATA8  lModCall_8                                                   // The procedure within the module

    MOVEF_8(gParam1_F, lMod_8)
    MOVEF_8(gParam2_F, lModCall_8)
    CALL(cmdMod, lMod_8, lModCall_8)
    RETURN()

cmd_jmpc:
    DATA8  lFlag_8

    CALL(readMem8, 6, 0, lFlags_8)                                      // Read flags register from heap offset 6
    MOVEF_8(gParam1_F, lFlag_8)                                         // Get the flag to compare from the first parameter
    AND8(lFlags_8, lFlag_8, lFlags_8)                                   // lFlags_8 = lFlags_8 or lFlag_8
    JR_NEQ8(lFlags_8, 0, cmd_jmpc_flag)
    RETURN()
cmd_jmpc_flag:
    MOVEF_32(gParam2Value_F, lRegCode_32)
    SUB32(lRegCode_32, 1, lRegCode_32)                                  // lRegCode_32 = lRegCode_32 - 1
    CALL(writeMem32, 4, 0, lRegCode_32)                                 // Set the code register to the jump target
    RETURN()

cmd_call_ret:
    JR_EQ8(gType1_8, 0, cmd_call_ret_param1_constant)                   // Param1 is constant
    JR_EQ8(gType1_8, 2, cmd_call_ret_param1_local)                      // Param1 is local
    JR_EQ8(gType1_8, 1, cmd_call_ret_param1_global)                     // Param1 is global
    JR_EQ8(gType1_8, 3, cmd_call_ret_param1_pointer)                    // Param1 is pointer
    RETURN()                                                            // INVALID!
cmd_call_ret_param1_constant:
    MOVEF_F(gParam1_F, gParam1Value_F)
    JR(cmd_call_ret_param1_done)
cmd_call_ret_param1_global:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_call_ret_param1_done)
cmd_call_ret_param1_pointer:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lParam1Offset_32, lRegPtr_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_call_ret_param1_done)
cmd_call_ret_param1_local:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ADD32(lParam1Offset_32, lRegStack_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
cmd_call_ret_param1_done:

    DATA32 lStackAlloc_32

    JR_EQ8(gCommand_8, 1, cmd_ret)                                      // Ret
    CALL(readMem32, 4, 0, lRegCode_32)                                  // Read code register from heap offset 4
    MOVEF_32(gParam2_F, lStackAlloc_32)                                 // Convert the needed stack size to int32
    ADD32(lRegStack_32, lStackAlloc_32, lRegStackNew_32)
    CALL(writeMem32, lRegStackNew_32, -1, lRegCode_32)                  // Save the code register on the stack
    CALL(writeMem32, lRegStackNew_32, -2, lRegStack_32)                 // Save the stack register on the stack
    CALL(writeMem32, 0, 0, lRegStackNew_32)                             // Update the stack register
    CALL(writeMemF, 4, 0, gParam1Value_F)                               // Write the code register to heap offset 4
    RETURN()

cmd_ret:
    CALL(readMem32, lRegStack_32, -2, lRegStackNew_32)
    CALL(readMem32, lRegStack_32, -1, lRegCode_32)
    CALL(writeMem32, 0, 0, lRegStackNew_32)                             // Set the return stack register value
    CALL(writeMem32, 4, 0, lRegCode_32)                                 // Set the return code register value

    JR_EQ8(gKeepRet_8, 1, cmd_ret_keep)
    CALL(writeMemF, 5, 0, gParam1Value_F)                               // Set the return register
    RETURN()
cmd_ret_keep:
    MOVE8_8(0, gKeepRet_8)
    RETURN()

cmd_operator:
    DATA32 lParam1Offset_32
    JR_EQ8(gType1_8, 2, param1_local)                                   // Param2 is local
    JR_EQ8(gType1_8, 1, param1_global)                                  // Param2 is global
    JR_EQ8(gType1_8, 3, param1_pointer)                                 // Param2 is pointer
    RETURN()                                                            // INVALID!
param1_global:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    JR(param1_done)
param1_pointer:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lParam1Offset_32, lRegPtr_32, lParam1Offset_32)
    JR(param1_done)
param1_local:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ADD32(lParam1Offset_32, lRegStack_32, lParam1Offset_32)
param1_done:
    JR_EQ8(gCommand_8, 5, cmd_set)                                      // Set, we don't read gParam1Value_F
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR_EQ8(gCommand_8,  6, cmd_add)
    JR_EQ8(gCommand_8,  7, cmd_sub)
    JR_EQ8(gCommand_8,  8, cmd_mul)
    JR_EQ8(gCommand_8,  9, cmd_div)
    JR_EQ8(gCommand_8, 10, cmd_and)
    JR_EQ8(gCommand_8, 11, cmd_or)
    JR_EQ8(gCommand_8, 12, cmd_cmp)
    JR_EQ8(gCommand_8, 13, cmd_setf)
    JR_EQ8(gCommand_8, 14, cmd_sets)
    JR_EQ8(gCommand_8, 15, cmd_adds)
    RETURN()                                                            // INVALID!

cmd_add:
    ADDF(gParam1Value_F, gParam2Value_F, gParam2Value_F)
    JR(param1_write)

cmd_sub:
    SUBF(gParam1Value_F, gParam2Value_F, gParam2Value_F)
    JR(param1_write)

cmd_mul:
    MULF(gParam1Value_F, gParam2Value_F, gParam2Value_F)
    JR(param1_write)

cmd_div:
    DIVF(gParam1Value_F, gParam2Value_F, gParam2Value_F)
    JR(param1_write)

cmd_and:
    JR_EQF(gParam1Value_F, 0, cmd_and_not_true)
    JR_EQF(gParam2Value_F, 0, cmd_and_not_true)
    MOVEF_F(1, gParam2Value_F)
    JR(param1_write)
cmd_and_not_true:
    MOVEF_F(0, gParam2Value_F)
    JR(param1_write)

cmd_or:
    JR_NEQF(gParam1Value_F, 0, cmd_or_true)
    JR_NEQF(gParam2Value_F, 0, cmd_or_true)
    MOVEF_F(0, gParam2Value_F)
    JR(param1_write)
cmd_or_true:
    MOVEF_F(1, gParam2Value_F)
    JR(param1_write)

cmd_cmp:
    MOVE8_8(0, lFlags_8)                                                // Set the flags to 0
    JR_EQF(gParam1Value_F, gParam2Value_F, cmd_cmp_eq)
    OR8(lFlags_8,  2, lFlags_8)                                         // Set not equal flag
    JR_LTF(gParam1Value_F, gParam2Value_F, cmd_cmp_lt)
    OR8(lFlags_8, 48, lFlags_8)                                         // Set greater/greater_equal flag
    JR(cmd_cmp_eq_done)
cmd_cmp_lt:
    OR8(lFlags_8, 12, lFlags_8)                                         // Set less/less_equal flag
    JR(cmd_cmp_eq_done)
cmd_cmp_eq:
    OR8(lFlags_8, 41, lFlags_8)                                         // Set equal/greater_equal/less_equal flag
cmd_cmp_eq_done:
    CALL(writeMem8, 6, 0, lFlags_8)                                     // Write the flags register to the heap
    RETURN()

cmd_setf:
    CALL(readMem8, 6, 0, lFlags_8)                                      // Read flags register from heap offset 6
    DATA8 lFlag_8
    MOVEF_8(gParam2_F, lFlag_8)
    AND8(lFlags_8, lFlag_8, lFlag_8)                                    // lFlag_8 = lFlags_8 & lFlag_8
    MOVE8_F(lFlag_8, gParam2Value_F)
    JR(param1_write)

cmd_sets:
    JR_EQ8(gType1_8, 0, cmd_sets_param1_constant)                       // Param1 is constant
    JR_EQ8(gType1_8, 2, cmd_sets_param1_local)                          // Param1 is local
    JR_EQ8(gType1_8, 1, cmd_sets_param1_global)                         // Param1 is global
    JR_EQ8(gType1_8, 3, cmd_sets_param1_pointer)                        // Param1 is pointer
    RETURN()                                                            // INVALID!
cmd_sets_param1_constant:
    MOVEF_F(gParam1_F, gParam1Value_F)
    JR(cmd_sets_param1_done)
cmd_sets_param1_global:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_sets_param1_done)
cmd_sets_param1_pointer:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lParam1Offset_32, lRegPtr_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
    JR(cmd_sets_param1_done)
cmd_sets_param1_local:
    MOVEF_32(gParam1_F, lParam1Offset_32)
    ADD32(lParam1Offset_32, lRegStack_32, lParam1Offset_32)
    ARRAY_READ(gHeap_H, lParam1Offset_32, gParam1Value_F)               // gParam1Value_F = [lParam1Offset_32]
cmd_sets_param1_done:
    DATA32 lStringOffset1_32
    DATA32 lStringOffset2_32
    DATA8  lStringLength_8
    DATA8  lStringIndex_8
    DATA8  lChar_8
    MOVEF_32(gParam1Value_F, lStringOffset1_32)
    MOVEF_32(gParam2Value_F, lStringOffset2_32)

    MUL32(lStringOffset1_32, gStringDataSize_32, lStringOffset1_32)
    MUL32(lStringOffset2_32, gStringDataSize_32, lStringOffset2_32)
    ARRAY_READ(gStrings_H, lStringOffset2_32, lStringLength_8)
    ARRAY_WRITE(gStrings_H, lStringOffset1_32, lStringLength_8)
    MOVE8_8(0, lStringIndex_8)
cmd_sets_loop:
    ADD32(lStringOffset1_32, 1, lStringOffset1_32)
    ADD32(lStringOffset2_32, 1, lStringOffset2_32)
    ARRAY_READ(gStrings_H, lStringOffset2_32, lChar_8)
    ARRAY_WRITE(gStrings_H, lStringOffset1_32, lChar_8)
    ADD8(lStringIndex_8, 1, lStringIndex_8)
    JR_LT8(lStringIndex_8, lStringLength_8, cmd_sets_loop)
    RETURN()

cmd_adds:
    CALL(cmdAddS)
    RETURN()
cmd_set:
param1_write:
    ARRAY_WRITE(gHeap_H, lParam1Offset_32, gParam2Value_F)
}

subcall cmdAddS {                                                       // Todo: max string length check!!!
    DATA32 lSrcStringOffset_32
    DATA8  lSrcStringLength_8
    DATA32 lDestStringOffset_32
    DATA8  lDestStringLength_8
    DATA8  lStringLength_8
    DATA32 lOffset_32
    DATA8  lChar_8
    DATA8  lIndex_8

    MOVEF_32(gParam2Value_F, lSrcStringOffset_32)
    MUL32(lSrcStringOffset_32, gStringDataSize_32, lSrcStringOffset_32)
    ARRAY_READ(gStrings_H, lSrcStringOffset_32, lSrcStringLength_8)

    MOVEF_32(gParam1Value_F, lDestStringOffset_32)
    MUL32(lDestStringOffset_32, gStringDataSize_32, lDestStringOffset_32)
    ARRAY_READ(gStrings_H, lDestStringOffset_32, lDestStringLength_8)

    ADD8(lSrcStringLength_8, lDestStringLength_8, lStringLength_8)      ; New string length = src length + dest length
    ARRAY_WRITE(gStrings_H, lDestStringOffset_32, lStringLength_8)

    MOVE8_32(lDestStringLength_8, lOffset_32)
    ADD32(lDestStringOffset_32, lOffset_32, lDestStringOffset_32)       ; Dest offset = dest offset + src length

    MOVE8_8(0, lIndex_8)
loop:
    ADD32(lSrcStringOffset_32, 1, lSrcStringOffset_32)
    ADD32(lDestStringOffset_32, 1, lDestStringOffset_32)

    ARRAY_READ(gStrings_H, lSrcStringOffset_32, lChar_8)
    ARRAY_WRITE(gStrings_H, lDestStringOffset_32, lChar_8)

    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lSrcStringLength_8, loop)
}

//=================================================================================================//
//
// File: vm/vmRead.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall readCommand {
    DATA32 lRegCode_32

    CALL(readMem32, 4, 0, lRegCode_32)                                  // Read code register from heap offset 4
    MUL32(lRegCode_32, 3, gCommandListOffset_32)
    ARRAY_READ(gCommandList_H, gCommandListOffset_32, gCommand_8)
    ADD32(gCommandListOffset_32, 1, gCommandListOffset_32)
    ARRAY_READ(gCommandList_H, gCommandListOffset_32, gType1_8)
    ADD32(gCommandListOffset_32, 1, gCommandListOffset_32)
    ARRAY_READ(gCommandList_H, gCommandListOffset_32, gType2_8)
    MUL32(lRegCode_32, 2, gCommandParamOffset_32)
    ARRAY_READ(gCommandParam_H, gCommandParamOffset_32, gParam1_F)
    ADD32(gCommandParamOffset_32, 1, gCommandParamOffset_32)
    ARRAY_READ(gCommandParam_H, gCommandParamOffset_32, gParam2_F)
}

//=================================================================================================//

subcall readMem8 {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    OUT_8 pValue_8
    DATAF lValue_F

    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_READ(gHeap_H, pOffset1_32, lValue_F)
    MOVEF_8(lValue_F, pValue_8)
}

subcall readMem16 {
    IN_32  pOffset1_32
    IN_32  pOffset2_32
    OUT_16 pValue_16
    DATAF  lValue_F

    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_READ(gHeap_H, pOffset1_32, lValue_F)
    MOVEF_32(lValue_F, pValue_16)
}

subcall readMem32 {
    IN_32  pOffset1_32
    IN_32  pOffset2_32
    OUT_32 pValue_32
    DATAF  lValue_F

    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_READ(gHeap_H, pOffset1_32, lValue_F)
    MOVEF_32(lValue_F, pValue_32)
}

subcall readMemF {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    OUT_F pValue_F

    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_READ(gHeap_H, pOffset1_32, pValue_F)
}

//=================================================================================================//

subcall readString {
    IN_16  pIndex_16
    DATA8  lChar_8
    DATA8  lIndex_8
    DATA16 lStringLength_16
    DATA8  lStringLength_8
    DATA32 lStringOffset_32

    MOVE16_32(pIndex_16, lStringOffset_32)
    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = pIndex_16 * gStringDataSize_32
    ARRAY_READ(gStrings_H, lStringOffset_32, lStringLength_8)           // Read the string length
    ADD32(lStringOffset_32, 1, lStringOffset_32)

    MOVE8_8(0, lIndex_8)
loop:
    ARRAY_READ(gStrings_H, lStringOffset_32, lChar_8)
    WRITE8(lChar_8, lIndex_8, @gString_H)                               // Copy the string chars
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lStringLength_8, loop)

    MOVE8_8(0, lChar_8)
    WRITE8(lChar_8, lIndex_8, @gString_H)                               // Set the zero char at the end
}

subcall readStringLength {
    IN_16  pIndex_16
    OUT_8  pStringLength_8
    DATA32 lStringOffset_32

    MOVE16_32(pIndex_16, lStringOffset_32)
    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = pIndex_16 * gStringDataSize_32
    ARRAY_READ(gStrings_H, lStringOffset_32, pStringLength_8)           // Read the string length
}

//=================================================================================================//
//
// File: vm/vmWrite.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall writeMem8 {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    IN_8  pValue_8
    DATAF lValue_F

    MOVE8_F(pValue_8, lValue_F)
    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_WRITE(gHeap_H, pOffset1_32, lValue_F)
}

subcall writeMem16 {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    IN_16 pValue_16
    DATAF lValue_F

    MOVE16_F(pValue_16, lValue_F)
    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_WRITE(gHeap_H, pOffset1_32, lValue_F)
}

subcall writeMem32 {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    IN_32 pValue_32
    DATAF lValue_F

    MOVE32_F(pValue_32, lValue_F)
    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_WRITE(gHeap_H, pOffset1_32, lValue_F)
}

subcall writeMemF {
    IN_32 pOffset1_32
    IN_32 pOffset2_32
    IN_F  pValue_F

    ADD32(pOffset1_32, pOffset2_32, pOffset1_32)
    ARRAY_WRITE(gHeap_H, pOffset1_32, pValue_F)
}

//=================================================================================================//

subcall writeString {
    IN_16  pIndex_16
    DATA8  lChar_8
    DATA8  lIndex_8
    DATA16 lStringLength_16
    DATA8  lStringLength_8
    DATA32 lStringOffset_32

    MOVE16_32(pIndex_16, lStringOffset_32)
    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = pIndex_16 * gStringDataSize_32

    STRINGS(GET_SIZE, @gString_H, lStringLength_16)
    MOVE16_8(lStringLength_16, lStringLength_8)
    ARRAY_WRITE(gStrings_H, lStringOffset_32, lStringLength_8)          // Save the string length
    ADD32(lStringOffset_32, 1, lStringOffset_32)

    MOVE8_8(0, lIndex_8)
loop:
    READ8(@gString_H, lIndex_8, lChar_8)
    ARRAY_WRITE(gStrings_H, lStringOffset_32, lChar_8)                  // Copy the string chars
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lStringLength_8, loop)
}

//=================================================================================================//

subcall releaseString {
    DATA16 lStringCount_16
    CALL(readMem16, 1, 0, lStringCount_16)                              // Read code src from heap offset 1
    SUB16(gStringCount_16, lStringCount_16, gStringCount_16)            // gStringCount_16 = gStringCount_16 - LStringCount_16
}

//=================================================================================================//
//
// File: vm/vmMod.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall cmdMod {
    IN_8   pMod_8
    IN_8   pModCall_8
    DATA32 lRegSrc_32

    CALL(readMem32, 1, 0, lRegSrc_32)                                   // Read the src register from heap
    JR_EQ8(pMod_8,  0, mod_standard)
    JR_EQ8(pMod_8,  1, mod_math)
    JR_EQ8(pMod_8,  2, mod_screen)
    JR_EQ8(pMod_8,  3, mod_light)
    JR_EQ8(pMod_8,  4, mod_button)
    JR_EQ8(pMod_8,  5, mod_sound)
    JR_EQ8(pMod_8,  6, mod_motor)
    JR_EQ8(pMod_8,  7, mod_sensor)
    JR_EQ8(pMod_8,  8, mod_file)
    JR_EQ8(pMod_8,  9, mod_system)
    JR_EQ8(pMod_8, 10, mod_string)
    JR_EQ8(pMod_8, 11, mod_bit)
    RETURN()

mod_standard:
    CALL(modStandard, pModCall_8, lRegSrc_32)
    RETURN()

mod_math:
    CALL(modMath, pModCall_8, lRegSrc_32)
    RETURN()

mod_screen:
    CALL(modScreen, pModCall_8, lRegSrc_32)
    RETURN()

mod_light:
    CALL(modLight, pModCall_8, lRegSrc_32)
    RETURN()

mod_button:
    CALL(modButton, pModCall_8, lRegSrc_32)
    RETURN()

mod_sound:
    CALL(modSound, pModCall_8, lRegSrc_32)
    RETURN()

mod_motor:
    CALL(modMotor, pModCall_8, lRegSrc_32)
    RETURN()

mod_sensor:
    CALL(modSensor, pModCall_8, lRegSrc_32)
    RETURN()

mod_file:
    CALL(modFile, pModCall_8, lRegSrc_32)
    RETURN()

mod_system:
    CALL(modSystem, pModCall_8, lRegSrc_32)
    RETURN()

mod_string:
    CALL(modString, pModCall_8, lRegSrc_32)
    RETURN()

mod_bit:
    CALL(modBit, pModCall_8, lRegSrc_32)
    RETURN()
}

//=================================================================================================//
//
// File: vm/vmUtils.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall setRet8AndKeep {
    IN_8  pValue_8
    DATAF lValue_F
    MOVE8_F(pValue_8, lValue_F)
    ARRAY_WRITE(gHeap_H, 5, lValue_F)
    MOVE8_8(1, gKeepRet_8)
}

subcall setRet16AndKeep {
    IN_16 pValue_16
    DATAF lValue_F
    MOVE16_F(pValue_16, lValue_F)
    ARRAY_WRITE(gHeap_H, 5, lValue_F)
    MOVE8_8(1, gKeepRet_8)
}

subcall setRet32AndKeep {
    IN_32 pValue_32
    DATAF lValue_F
    MOVE32_F(pValue_32, lValue_F)
    ARRAY_WRITE(gHeap_H, 5, lValue_F)
    MOVE8_8(1, gKeepRet_8)
}

subcall setRetFAndKeep {
    IN_F pValue_F
    ARRAY_WRITE(gHeap_H, 5, pValue_F)
    MOVE8_8(1, gKeepRet_8)
}

//=================================================================================================//

subcall print8 {
    IN_8  pValue_8
    IN_16 pX_16
    IN_16 pY_16
    DATAF lValue_F
    MOVE8_F(pValue_8, lValue_F)
    CALL(printF, lValue_F, pX_16, pY_16)
}

subcall print16 {
    IN_16 pValue_16
    IN_16 pX_16
    IN_16 pY_16
    DATAF lValue_F
    MOVE16_F(pValue_16, lValue_F)
    CALL(printF, lValue_F, pX_16, pY_16)
}

subcall print32 {
    IN_32 pValue_32
    IN_16 pX_16
    IN_16 pY_16
    DATAF lValue_F
    MOVE32_F(pValue_32, lValue_F)
    CALL(printF, lValue_F, pX_16, pY_16)
}

subcall printF {
    IN_F   pValue_F
    IN_16  pX_16
    IN_16  pY_16
    HANDLE lString_H
    ARRAY(CREATE8, 32, lString_H)
    STRINGS(VALUE_TO_STRING, pValue_F, -16, 4, @lString_H)
    UI_DRAW(TEXT, 1, pX_16, pY_16, @lString_H)
    ARRAY(DELETE, lString_H)
}

//=================================================================================================//
//
// File: vm/modStandard.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modStandard {                                                   // 00) STANDARD
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA32 lTime1_32
    DATA32 lTime2_32

    JR_EQ8(pModCall_8, 4, mod_standard_sleep)
    JR_EQ8(pModCall_8, 5, mod_standard_stop_vm)
    JR_EQ8(pModCall_8, 6, mod_standard_stop_program)
    JR_EQ8(pModCall_8, 7, mod_standard_get_time)
    RETURN()

mod_standard_sleep:                                                     // 05) standardSleep
    UI_DRAW(UPDATE)
    CALL(readMem32, pRegSrc_32, 0, lTime1_32)
    DATA32 lCurrentTime_32
    DATA32 lEndTime_32
    TIMER_READ(lCurrentTime_32)
    ADD32(lCurrentTime_32, lTime1_32, lEndTime_32)
mod_standard_sleep_wait:
    TIMER_READ(lCurrentTime_32)
    SLEEP()
    JR_LT32(lCurrentTime_32, lEndTime_32, mod_standard_sleep_wait)
    RETURN()

mod_standard_stop_vm:                                                   // 06) standardStopVM
    RETURN()

mod_standard_stop_program:                                              // 07) standardStopProgram
    RETURN()

mod_standard_get_time:                                                  // 08) standardGetTime
    TIMER_READ(lTime1_32)
    CALL(setRet32AndKeep, lTime1_32)
    RETURN()
}

//=================================================================================================//
//
// File: vm/modMath.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMath {                                                       // 01) MATH
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATAF  lI_F
    DATAF  lJ_F
    DATAF  lK_F
    DATA16 lX_16
    DATA16 lY_16
    DATA16 lZ_16
    DATA32 lQ_32
    DATA32 lR_32
    DATA32 lS_32

    JR_EQ8(pModCall_8,  0, mod_math_round)
    JR_EQ8(pModCall_8,  1, mod_math_floor)
    JR_EQ8(pModCall_8,  2, mod_math_ceil)
    JR_EQ8(pModCall_8,  3, mod_math_abs)
    JR_EQ8(pModCall_8,  4, mod_math_neg)
    JR_EQ8(pModCall_8,  5, mod_math_random)
    JR_EQ8(pModCall_8,  6, mod_math_sin)
    JR_EQ8(pModCall_8,  7, mod_math_cos)
    JR_EQ8(pModCall_8,  8, mod_math_tan)
    JR_EQ8(pModCall_8,  9, mod_math_asin)
    JR_EQ8(pModCall_8, 10, mod_math_acos)
    JR_EQ8(pModCall_8, 11, mod_math_atan)
    JR_EQ8(pModCall_8, 12, mod_math_remainder)
    JR_EQ8(pModCall_8, 13, mod_math_exp)
    JR_EQ8(pModCall_8, 14, mod_math_sqrt)
    JR_EQ8(pModCall_8, 15, mod_math_log)
    JR_EQ8(pModCall_8, 16, mod_math_pow)
    JR_EQ8(pModCall_8, 17, mod_math_odd)
    JR_EQ8(pModCall_8, 18, mod_math_even)
    RETURN()

mod_math_round:                                                         // 00) mathRound
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(ROUND, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_floor:                                                         // 01) mathFloor
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(FLOOR, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_ceil:                                                          // 02) mathCeil
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(CEIL, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_abs:                                                           // 03) mathAbs
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(ABS, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_neg:                                                           // 04) mathNeg
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(NEGATE, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_random:                                                        // 05) mathRandom
    CALL(readMem16, pRegSrc_32, 0, lX_16)
    CALL(readMem16, pRegSrc_32, 1, lY_16)
    RANDOM(lX_16, lY_16, lZ_16)
    CALL(setRet16AndKeep, lZ_16)
    RETURN()

mod_math_sin:                                                           // 06) mathSin
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MULF(lI_F, 57.29577951308232F, lI_F)
    MATH(SIN, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_cos:                                                           // 07) mathCos
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MULF(lI_F, 57.29577951308232F, lI_F)
    MATH(COS, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_tan:                                                           // 08) mathTan
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MULF(lI_F, 57.29577951308232F, lI_F)
    MATH(TAN, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_asin:                                                          // 09) mathASin
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(ASIN, lI_F, lI_F)
    DIVF(lI_F, 57.29577951308232F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_acos:                                                          // 10) mathACos
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(ACOS, lI_F, lI_F)
    DIVF(lI_F, 57.29577951308232F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_atan:                                                          // 11) mathATan
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(ATAN, lI_F, lI_F)
    DIVF(lI_F, 57.29577951308232F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_remainder:                                                     // 12) mathRemainder
    CALL(readMem32, pRegSrc_32, 0, lQ_32)
    CALL(readMem32, pRegSrc_32, 1, lR_32)
    MATH(MOD32, lQ_32, lR_32, lS_32)
    CALL(setRet32AndKeep, lS_32)
    RETURN()

mod_math_exp:                                                           // 13) mathExp
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(EXP, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_sqrt:                                                          // 14) mathSqrt
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(SQRT, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_log:                                                           // 15) mathLog
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    MATH(LOG, lI_F, lI_F)
    CALL(setRetFAndKeep, lI_F)
    RETURN()

mod_math_pow:                                                           // 16) mathPow
    CALL(readMemF, pRegSrc_32, 0, lI_F)
    CALL(readMemF, pRegSrc_32, 1, lJ_F)
    MATH(POW, lI_F, lJ_F, lK_F)
    CALL(setRetFAndKeep, lK_F)
    RETURN()

mod_math_odd:                                                           // 19) odd
    CALL(readMem32, pRegSrc_32, 0, lQ_32)
    AND16(lQ_32, 1, lR_32)
    CALL(setRet32AndKeep, lR_32)
    RETURN()

mod_math_even:                                                          // 20) even
    CALL(readMem32, pRegSrc_32, 0, lQ_32)
    ADD16(lQ_32, 1, lQ_32)
    AND16(lQ_32, 1, lQ_32)
    CALL(setRet32AndKeep, lQ_32)
    RETURN()
}

//=================================================================================================//
//
// File: vm/modScreenInit.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modScreenInit {
    UI_DRAW(FILLWINDOW, 0x00, 0, 0)                                     //  Clear screen
    UI_DRAW(UPDATE)                                                     //  Update the screen

    MOVE8_8(0, gModScreenUpdated_8)
    MOVE32_32(0, gModScreenUpdateTime_32)
    MOVE8_8(0, gModScreenFill_8)
    MOVE8_8(1, gModScreenFillColor_8)
    MOVE16_16(8, gModScreenCharSize_16)
}

//=================================================================================================//
//
// File: vm/modScreen.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modScreen {                                                     // 02) SCREEN
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA16 lX1_16
    DATA16 lY1_16
    DATA16 lX2_16
    DATA16 lY2_16
    DATAF  lN_F
    DATA16 lWidth_16
    DATA16 lHeight_16
    DATA16 lRadius_16
    DATA8  lString_H
    DATA16 lStringIndex_16
    DATA8  lStringLength_8
    DATA16 lStringLength_16

    MOVE8_8(1, gModScreenUpdated_8)

    JR_EQ8(pModCall_8,  0, mod_screen_clear)
    JR_EQ8(pModCall_8,  1, mod_screen_fill)
    JR_EQ8(pModCall_8,  2, mod_screen_fill_color)
    JR_EQ8(pModCall_8,  3, mod_screen_text_size)
    JR_EQ8(pModCall_8,  4, mod_screen_text_align)
    JR_EQ8(pModCall_8,  5, mod_screen_draw_pixel)
    JR_EQ8(pModCall_8,  6, mod_screen_draw_number)
    JR_EQ8(pModCall_8,  7, mod_screen_draw_text)
    JR_EQ8(pModCall_8,  8, mod_screen_draw_line)
    JR_EQ8(pModCall_8,  9, mod_screen_draw_rect)
    JR_EQ8(pModCall_8, 10, mod_screen_draw_circle)
    JR_EQ8(pModCall_8, 11, mod_screen_draw_image)
    RETURN()

mod_screen_clear:                                                       // 00) screenClear
    UI_DRAW(FILLWINDOW, 0x00, 0, 0)
    RETURN()

mod_screen_fill:                                                        // 01) screenFill
    CALL(readMem8, pRegSrc_32, 0, gModScreenFill_8)
    RETURN()

mod_screen_fill_color:                                                  // 02) screenFillColor
    CALL(readMem8, pRegSrc_32, 0, gModScreenFillColor_8)
    UI_DRAW(UPDATE)
    RETURN()

mod_screen_text_size:                                                   // 03) screenTextSize
    CALL(readMem8, pRegSrc_32, 0, gModScreenTextSize_8)
    JR_EQ8(gModScreenTextSize_8, 2, mod_screen_text_size2)
    MOVE16_16(8, gModScreenCharSize_16)
    RETURN()
mod_screen_text_size2:
    MOVE16_16(16, gModScreenCharSize_16)
    RETURN()

mod_screen_text_align:                                                  // 04) screenTextAlign
    CALL(readMem8, pRegSrc_32, 0, gModScreenTextAlign_8)
    RETURN()

mod_screen_draw_pixel:                                                  // 05) screenDrawPixel
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    UI_DRAW(PIXEL, gModScreenFillColor_8, lX1_16, lY1_16)
    RETURN()

mod_screen_draw_number:                                                 // 06) screenDrawNumber
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMemF, pRegSrc_32, 2, lN_F)

    STRINGS(VALUE_TO_STRING, lN_F, -16, 4, @gString_H)

    JR_EQ8(gModScreenTextAlign_8, 0, mod_screen_draw_number_align_done) // Align the text...
    STRINGS(GET_SIZE, @gString_H, lStringLength_16)
    MUL16(lStringLength_16, gModScreenCharSize_16, lStringLength_16)
    JR_EQ8(gModScreenTextAlign_8, 2, mod_screen_draw_number_align_right)
    DIV16(lStringLength_16, 2, lStringLength_16)                        // Align center
mod_screen_draw_number_align_right:
    SUB16(lX1_16, lStringLength_16, lX1_16)                             // Align right
mod_screen_draw_number_align_done:

    UI_DRAW(SELECT_FONT, gModScreenTextSize_8)
    UI_DRAW(TEXT, gModScreenFillColor_8, lX1_16, lY1_16, @gString_H)
    RETURN()

mod_screen_draw_text:                                                   // 07) screenDrawNumber
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMem16, pRegSrc_32, 2, lStringIndex_16)                     // Read the pointer to string

    JR_EQ8(gModScreenTextAlign_8, 0, mod_screen_draw_text_align_done)   // Align the text...
    CALL(readStringLength, lStringIndex_16, lStringLength_8)
    MOVE8_16(lStringLength_8, lStringLength_16)
    MUL16(lStringLength_16, gModScreenCharSize_16, lStringLength_16)
    JR_EQ8(gModScreenTextAlign_8, 2, mod_screen_draw_text_align_right)
    DIV16(lStringLength_16, 2, lStringLength_16)                        // Align center
mod_screen_draw_text_align_right:
    SUB16(lX1_16, lStringLength_16, lX1_16)                             // Align right
mod_screen_draw_text_align_done:

    CALL(readString, lStringIndex_16)                                   // Read the string
    UI_DRAW(SELECT_FONT, gModScreenTextSize_8)
    UI_DRAW(TEXT, gModScreenFillColor_8, lX1_16, lY1_16, @gString_H)
    RETURN()

mod_screen_draw_line:                                                   // 08) screenDrawLine
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMem16, pRegSrc_32, 2, lX2_16)
    CALL(readMem16, pRegSrc_32, 3, lY2_16)
    UI_DRAW(LINE, gModScreenFillColor_8, lX1_16, lY1_16, lX2_16, lY2_16)
    RETURN()

mod_screen_draw_rect:                                                   // 09) screenDrawRect
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMem16, pRegSrc_32, 2, lWidth_16)
    CALL(readMem16, pRegSrc_32, 3, lHeight_16)
    JR_NEQ8(gModScreenFill_8, 0, mod_screen_draw_fillrect)
    UI_DRAW(RECT, gModScreenFillColor_8, lX1_16, lY1_16, lWidth_16, lHeight_16)
    RETURN()

mod_screen_draw_fillrect:
    UI_DRAW(FILLRECT, gModScreenFillColor_8, lX1_16, lY1_16, lWidth_16, lHeight_16)
    RETURN()

mod_screen_draw_circle:                                                 // 10) screenDrawCircle
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMem16, pRegSrc_32, 2, lRadius_16)
    JR_NEQ8(gModScreenFill_8, 0, mod_screen_draw_fillcircle)
    UI_DRAW(CIRCLE, gModScreenFillColor_8, lX1_16, lY1_16, lRadius_16)
    RETURN()

mod_screen_draw_fillcircle:
    UI_DRAW(FILLCIRCLE, gModScreenFillColor_8, lX1_16, lY1_16, lRadius_16)
    RETURN()

mod_screen_draw_image:                                                  // 11) screenDrawImage
    CALL(readMem16, pRegSrc_32, 0, lX1_16)
    CALL(readMem16, pRegSrc_32, 1, lY1_16)
    CALL(readMem16, pRegSrc_32, 2, lStringIndex_16)
    CALL(readString, lStringIndex_16)
    UI_DRAW(BMPFILE, gModScreenFillColor_8, lX1_16, lY1_16, @gString_H)
}

//=================================================================================================//
//
// File: vm/modLight.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modLight {                                                      // 03) LIGHT
    IN_8  pModCall_8
    IN_32 pRegSrc_32
    DATA8 lColor_8

    JR_EQ8(pModCall_8,  0, mod_light_update)
    RETURN()
mod_light_update:                                                       // 01) lightUpdate
    CALL(readMem8, pRegSrc_32, 0, lColor_8)
    UI_WRITE(LED, lColor_8)
    RETURN()
}

//=================================================================================================//
//
// File: vm/modButton.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modButton {                                                     // 04) BUTTON
    IN_8  pModCall_8
    IN_32 pRegSrc_32

    JR_EQ8(pModCall_8,  0, mod_button_read)
    JR_EQ8(pModCall_8,  1, mod_button_wait_for_press)
    RETURN()

mod_button_read:                                                        // 00) buttonRead
    DATA8 lButton_8
    DATA8 lPressed_8
    MOVE8_8(0, lButton_8)
mod_button_read_loop:
    ADD8(lButton_8, 1, lButton_8)
    UI_BUTTON(PRESSED, lButton_8, lPressed_8)                           // Read button
    JR_EQ8(lPressed_8, 1, mod_button_pressed)                           // Check if the button is pressed
    JR_LT8(lButton_8, 6, mod_button_read_loop)                          // More buttons to check?
    MOVE8_8(0, lButton_8)                                               // No pressed button found
mod_button_pressed:
    CALL(setRet8AndKeep, lButton_8)
    RETURN()

mod_button_wait_for_press:
    UI_BUTTON(FLUSH)
    UI_BUTTON(WAIT_FOR_PRESS)                                           // 01) Wait for button press
}

//=================================================================================================//
//
// File: vm/modSound.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modSound {                                                      // 05) SOUND
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA8  lVolume_8
    DATA16 lFrequency_16
    DATA16 lDuration_16
    DATA16 lStringIndex_16

    JR_EQ8(pModCall_8, 0, mod_sound_tone)
    JR_EQ8(pModCall_8, 1, mod_sound_sample)
    RETURN()

mod_sound_tone:                                                         // 00) soundPlayTone
    CALL(readMem16, pRegSrc_32, 0, lFrequency_16)
    CALL(readMem16, pRegSrc_32, 1, lDuration_16)
    CALL(readMem8,  pRegSrc_32, 2, lVolume_8)

    SOUND(TONE, lVolume_8, lFrequency_16, lDuration_16)
    RETURN()

mod_sound_sample:
    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)
    CALL(readString, lStringIndex_16)
    CALL(readMem8,  pRegSrc_32, 1, lVolume_8)

    DATA16 lStringLength_16                                             // The play command does not accept .rtf extensions...
    DATA32 lStringLength_32
    DATA8  lChar_8
    MOVE8_8(0, lChar_8)
    STRINGS(GET_SIZE, @gString_H, lStringLength_16)                     // Get the string length
    MOVE32_16(lStringLength_16, lStringLength_32)
    SUB16(lStringLength_32, 4, lStringLength_32)                        // Remove 4 characters for the .rtf extension
    ARRAY_WRITE(gString_H, lStringLength_32, lChar_8)                   // Set a new zero char to remove the extension!

    SOUND(PLAY, lVolume_8, @gString_H)
}

//=================================================================================================//
//
// File: vm/modMotorInit.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotorInit {
    //== LAYER 1 ==================================================================================//

    MOVE8_8(0, gModMotor1AStarted_8);
    MOVE8_8(0, gModMotor1AMode_8)
    MOVE8_8(1, gModMotor1AReady_8)
    MOVE8_8(0, gModMotor1ASpeed_8)
    MOVE8_8(1, gModMotor1ABrake_8)
    MOVE32_32(0, gModMotor1ACurrrent_32)
    MOVE32_32(0, gModMotor1ATarget_32)
    MOVE32_32(0, gModMotor1ATime_32)

    MOVE8_8(0, gModMotor1BStarted_8);
    MOVE8_8(0, gModMotor1BMode_8)
    MOVE8_8(1, gModMotor1BReady_8)
    MOVE8_8(0, gModMotor1BSpeed_8)
    MOVE8_8(1, gModMotor1BBrake_8)
    MOVE32_32(0, gModMotor1BCurrrent_32)
    MOVE32_32(0, gModMotor1BTarget_32)
    MOVE32_32(0, gModMotor1BTime_32)

    MOVE8_8(0, gModMotor1CStarted_8);
    MOVE8_8(0, gModMotor1CMode_8)
    MOVE8_8(1, gModMotor1CReady_8)
    MOVE8_8(0, gModMotor1CSpeed_8)
    MOVE8_8(1, gModMotor1CBrake_8)
    MOVE32_32(0, gModMotor1CCurrrent_32)
    MOVE32_32(0, gModMotor1CTarget_32)
    MOVE32_32(0, gModMotor1CTime_32)

    MOVE8_8(0, gModMotor1DStarted_8);
    MOVE8_8(0, gModMotor1DMode_8)
    MOVE8_8(1, gModMotor1DReady_8)
    MOVE8_8(0, gModMotor1DSpeed_8)
    MOVE8_8(1, gModMotor1DBrake_8)
    MOVE32_32(0, gModMotor1DCurrrent_32)
    MOVE32_32(0, gModMotor1DTarget_32)
    MOVE32_32(0, gModMotor1DTime_32)

    //== LAYER 2 ==================================================================================//

    MOVE8_8(0, gModMotor2AStarted_8);
    MOVE8_8(0, gModMotor2AMode_8)
    MOVE8_8(1, gModMotor2AReady_8)
    MOVE8_8(0, gModMotor2ASpeed_8)
    MOVE8_8(1, gModMotor2ABrake_8)
    MOVE32_32(0, gModMotor2ACurrrent_32)
    MOVE32_32(0, gModMotor2ATarget_32)
    MOVE32_32(0, gModMotor2ATime_32)

    MOVE8_8(0, gModMotor2BStarted_8);
    MOVE8_8(0, gModMotor2BMode_8)
    MOVE8_8(1, gModMotor2BReady_8)
    MOVE8_8(0, gModMotor2BSpeed_8)
    MOVE8_8(1, gModMotor2BBrake_8)
    MOVE32_32(0, gModMotor2BCurrrent_32)
    MOVE32_32(0, gModMotor2BTarget_32)
    MOVE32_32(0, gModMotor2BTime_32)

    MOVE8_8(0, gModMotor2CStarted_8);
    MOVE8_8(0, gModMotor2CMode_8)
    MOVE8_8(1, gModMotor2CReady_8)
    MOVE8_8(0, gModMotor2CSpeed_8)
    MOVE8_8(1, gModMotor2CBrake_8)
    MOVE32_32(0, gModMotor2CCurrrent_32)
    MOVE32_32(0, gModMotor2CTarget_32)
    MOVE32_32(0, gModMotor2CTime_32)

    MOVE8_8(0, gModMotor2DStarted_8);
    MOVE8_8(0, gModMotor2DMode_8)
    MOVE8_8(1, gModMotor2DReady_8)
    MOVE8_8(0, gModMotor2DSpeed_8)
    MOVE8_8(1, gModMotor2DBrake_8)
    MOVE32_32(0, gModMotor2DCurrrent_32)
    MOVE32_32(0, gModMotor2DTarget_32)
    MOVE32_32(0, gModMotor2DTime_32)

    //== LAYER 3 ==================================================================================//

    MOVE8_8(0, gModMotor3AStarted_8);
    MOVE8_8(0, gModMotor3AMode_8)
    MOVE8_8(1, gModMotor3AReady_8)
    MOVE8_8(0, gModMotor3ASpeed_8)
    MOVE8_8(1, gModMotor3ABrake_8)
    MOVE32_32(0, gModMotor3ACurrrent_32)
    MOVE32_32(0, gModMotor3ATarget_32)
    MOVE32_32(0, gModMotor3ATime_32)

    MOVE8_8(0, gModMotor3BStarted_8);
    MOVE8_8(0, gModMotor3BMode_8)
    MOVE8_8(1, gModMotor3BReady_8)
    MOVE8_8(0, gModMotor3BSpeed_8)
    MOVE8_8(1, gModMotor3BBrake_8)
    MOVE32_32(0, gModMotor3BCurrrent_32)
    MOVE32_32(0, gModMotor3BTarget_32)
    MOVE32_32(0, gModMotor3BTime_32)

    MOVE8_8(0, gModMotor3CStarted_8);
    MOVE8_8(0, gModMotor3CMode_8)
    MOVE8_8(1, gModMotor3CReady_8)
    MOVE8_8(0, gModMotor3CSpeed_8)
    MOVE8_8(1, gModMotor3CBrake_8)
    MOVE32_32(0, gModMotor3CCurrrent_32)
    MOVE32_32(0, gModMotor3CTarget_32)
    MOVE32_32(0, gModMotor3CTime_32)

    MOVE8_8(0, gModMotor3DStarted_8);
    MOVE8_8(0, gModMotor3DMode_8)
    MOVE8_8(1, gModMotor3DReady_8)
    MOVE8_8(0, gModMotor3DSpeed_8)
    MOVE8_8(1, gModMotor3DBrake_8)
    MOVE32_32(0, gModMotor3DCurrrent_32)
    MOVE32_32(0, gModMotor3DTarget_32)
    MOVE32_32(0, gModMotor3DTime_32)

    //== LAYER 4 ==================================================================================//

    MOVE8_8(0, gModMotor4AStarted_8);
    MOVE8_8(0, gModMotor4AMode_8)
    MOVE8_8(1, gModMotor4AReady_8)
    MOVE8_8(0, gModMotor4ASpeed_8)
    MOVE8_8(1, gModMotor4ABrake_8)
    MOVE32_32(0, gModMotor4ACurrrent_32)
    MOVE32_32(0, gModMotor4ATarget_32)
    MOVE32_32(0, gModMotor4ATime_32)

    MOVE8_8(0, gModMotor4BStarted_8);
    MOVE8_8(0, gModMotor4BMode_8)
    MOVE8_8(1, gModMotor4BReady_8)
    MOVE8_8(0, gModMotor4BSpeed_8)
    MOVE8_8(1, gModMotor4BBrake_8)
    MOVE32_32(0, gModMotor4BCurrrent_32)
    MOVE32_32(0, gModMotor4BTarget_32)
    MOVE32_32(0, gModMotor4BTime_32)

    MOVE8_8(0, gModMotor4CStarted_8);
    MOVE8_8(0, gModMotor4CMode_8)
    MOVE8_8(1, gModMotor4CReady_8)
    MOVE8_8(0, gModMotor4CSpeed_8)
    MOVE8_8(1, gModMotor4CBrake_8)
    MOVE32_32(0, gModMotor4CCurrrent_32)
    MOVE32_32(0, gModMotor4CTarget_32)
    MOVE32_32(0, gModMotor4CTime_32)

    MOVE8_8(0, gModMotor4DStarted_8);
    MOVE8_8(0, gModMotor4DMode_8)
    MOVE8_8(1, gModMotor4DReady_8)
    MOVE8_8(0, gModMotor4DSpeed_8)
    MOVE8_8(1, gModMotor4DBrake_8)
    MOVE32_32(0, gModMotor4DCurrrent_32)
    MOVE32_32(0, gModMotor4DTarget_32)
    MOVE32_32(0, gModMotor4DTime_32)

    DATA8 lLayer_8
    MOVE8_8(0, lLayer_8)
loop:
    CALL(modMotorResetMotor, lLayer_8, 101)
    CALL(modMotorResetMotor, lLayer_8, 102)
    CALL(modMotorResetMotor, lLayer_8, 103)
    CALL(modMotorResetMotor, lLayer_8, 104)
    ADD8(lLayer_8, 1, lLayer_8)
    JR_LT8(lLayer_8, 4, loop)
}

//=================================================================================================//
//
// File: vm/modMotor.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor {                                                      // 06) MOTOR
    IN_8  pModCall_8
    IN_32 pRegSrc_32

    JR_EQ8(pModCall_8,  0, mod_motor_set_type)
    JR_EQ8(pModCall_8,  1, mod_motor_set_speed)
    JR_EQ8(pModCall_8,  2, mod_motor_set_brake)
    JR_EQ8(pModCall_8,  3, mod_motor_get_type)
    JR_EQ8(pModCall_8,  4, mod_motor_reset)
    JR_EQ8(pModCall_8,  5, mod_motor_reverse)
    JR_EQ8(pModCall_8,  6, mod_motor_move_to)
    JR_EQ8(pModCall_8,  7, mod_motor_move_to_bits)
    JR_EQ8(pModCall_8,  8, mod_motor_on)
    JR_EQ8(pModCall_8,  9, mod_motor_time_on)
    JR_EQ8(pModCall_8, 10, mod_motor_stop)
    JR_EQ8(pModCall_8, 11, mod_motor_read)
    JR_EQ8(pModCall_8, 12, mod_motor_ready)
    RETURN()

mod_motor_set_type:                                                     // 00) motorSetType
    RETURN()

mod_motor_set_speed:                                                    // 01) motorSetSpeed
    CALL(modMotorSetSpeed, pRegSrc_32)
    RETURN()

mod_motor_set_brake:                                                    // 02) motorSetBrake
    CALL(modMotorSetBrake, pRegSrc_32)
    RETURN()

mod_motor_get_type:                                                     // 03) motorGetType
    CALL(modMotorGetType, pRegSrc_32)
    RETURN()

mod_motor_reset:                                                        // 04) motorReset
    CALL(modMotorReset, pRegSrc_32)
    RETURN()

mod_motor_reverse:                                                      // 05) motorReset
    RETURN()

mod_motor_move_to:                                                      // 06) motorMoveTo
    CALL(modMotorMoveTo, pRegSrc_32)
    RETURN()

mod_motor_move_to_bits:
    RETURN()

mod_motor_on:                                                           // 07) motorOn
    CALL(modMotorOn, pRegSrc_32)
    RETURN()

mod_motor_time_on:                                                      // 08) motorTimeOn
    CALL(modMotorTimeOn, pRegSrc_32)
    RETURN()

mod_motor_stop:                                                         // 09) motorStop
    CALL(modMotorStop, pRegSrc_32)
    RETURN()

mod_motor_read:                                                         // 10) motorRead
    CALL(modMotorRead, pRegSrc_32)
    RETURN()

mod_motor_ready:                                                        // 11) motorReady
    CALL(modMotorReady, pRegSrc_32)
}

subcall modMotorSetSpeed {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8
    DATA8 lSpeed_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)
    CALL(readMem8, pRegSrc_32, 2, lSpeed_8)

    JR_EQ8(lLayer_8, 0, mod_motor_set_speed_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_set_speed_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_set_speed_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_set_speed_layer4)
    RETURN()

mod_motor_set_speed_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_set_speed_1a)
    JR_EQ8(lPort_8, 1, mod_motor_set_speed_1b)
    JR_EQ8(lPort_8, 2, mod_motor_set_speed_1c)
    JR_EQ8(lPort_8, 3, mod_motor_set_speed_1d)
    RETURN()
mod_motor_set_speed_1a:
    MOVE8_8(lSpeed_8, gModMotor1ASpeed_8)
    RETURN()
mod_motor_set_speed_1b:
    MOVE8_8(lSpeed_8, gModMotor1BSpeed_8)
    RETURN()
mod_motor_set_speed_1c:
    MOVE8_8(lSpeed_8, gModMotor1CSpeed_8)
    RETURN()
mod_motor_set_speed_1d:
    MOVE8_8(lSpeed_8, gModMotor1DSpeed_8)
    RETURN()

mod_motor_set_speed_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_set_speed_2a)
    JR_EQ8(lPort_8, 1, mod_motor_set_speed_2b)
    JR_EQ8(lPort_8, 2, mod_motor_set_speed_2c)
    JR_EQ8(lPort_8, 3, mod_motor_set_speed_2d)
    RETURN()
mod_motor_set_speed_2a:
    MOVE8_8(lSpeed_8, gModMotor2ASpeed_8)
    RETURN()
mod_motor_set_speed_2b:
    MOVE8_8(lSpeed_8, gModMotor2BSpeed_8)
    RETURN()
mod_motor_set_speed_2c:
    MOVE8_8(lSpeed_8, gModMotor2CSpeed_8)
    RETURN()
mod_motor_set_speed_2d:
    MOVE8_8(lSpeed_8, gModMotor2DSpeed_8)
    RETURN()

mod_motor_set_speed_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_set_speed_3a)
    JR_EQ8(lPort_8, 1, mod_motor_set_speed_3b)
    JR_EQ8(lPort_8, 2, mod_motor_set_speed_3c)
    JR_EQ8(lPort_8, 3, mod_motor_set_speed_3d)
    RETURN()
mod_motor_set_speed_3a:
    MOVE8_8(lSpeed_8, gModMotor3ASpeed_8)
    RETURN()
mod_motor_set_speed_3b:
    MOVE8_8(lSpeed_8, gModMotor3BSpeed_8)
    RETURN()
mod_motor_set_speed_3c:
    MOVE8_8(lSpeed_8, gModMotor3CSpeed_8)
    RETURN()
mod_motor_set_speed_3d:
    MOVE8_8(lSpeed_8, gModMotor3DSpeed_8)
    RETURN()

mod_motor_set_speed_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_set_speed_4a)
    JR_EQ8(lPort_8, 1, mod_motor_set_speed_4b)
    JR_EQ8(lPort_8, 2, mod_motor_set_speed_4c)
    JR_EQ8(lPort_8, 3, mod_motor_set_speed_4d)
    RETURN()
mod_motor_set_speed_4a:
    MOVE8_8(lSpeed_8, gModMotor4ASpeed_8)
    RETURN()
mod_motor_set_speed_4b:
    MOVE8_8(lSpeed_8, gModMotor4BSpeed_8)
    RETURN()
mod_motor_set_speed_4c:
    MOVE8_8(lSpeed_8, gModMotor4CSpeed_8)
    RETURN()
mod_motor_set_speed_4d:
    MOVE8_8(lSpeed_8, gModMotor4DSpeed_8)
    RETURN()
}

subcall modMotorSetBrake {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8
    DATA8 lBrake_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)
    CALL(readMem8, pRegSrc_32, 2, lBrake_8)

    JR_EQ8(lLayer_8, 0, mod_motor_set_brake_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_set_brake_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_set_brake_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_set_brake_layer4)
    RETURN()

mod_motor_set_brake_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_set_brake_1a)
    JR_EQ8(lPort_8, 1, mod_motor_set_brake_1b)
    JR_EQ8(lPort_8, 2, mod_motor_set_brake_1c)
    JR_EQ8(lPort_8, 3, mod_motor_set_brake_1d)
    RETURN()
mod_motor_set_brake_1a:
    MOVE8_8(lBrake_8, gModMotor1ABrake_8)
    RETURN()
mod_motor_set_brake_1b:
    MOVE8_8(lBrake_8, gModMotor1BBrake_8)
    RETURN()
mod_motor_set_brake_1c:
    MOVE8_8(lBrake_8, gModMotor1CBrake_8)
    RETURN()
mod_motor_set_brake_1d:
    MOVE8_8(lBrake_8, gModMotor1DBrake_8)
    RETURN()

mod_motor_set_brake_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_set_brake_2a)
    JR_EQ8(lPort_8, 1, mod_motor_set_brake_2b)
    JR_EQ8(lPort_8, 2, mod_motor_set_brake_2c)
    JR_EQ8(lPort_8, 3, mod_motor_set_brake_2d)
    RETURN()
mod_motor_set_brake_2a:
    MOVE8_8(lBrake_8, gModMotor2ABrake_8)
    RETURN()
mod_motor_set_brake_2b:
    MOVE8_8(lBrake_8, gModMotor2BBrake_8)
    RETURN()
mod_motor_set_brake_2c:
    MOVE8_8(lBrake_8, gModMotor2CBrake_8)
    RETURN()
mod_motor_set_brake_2d:
    MOVE8_8(lBrake_8, gModMotor2DBrake_8)
    RETURN()

mod_motor_set_brake_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_set_brake_3a)
    JR_EQ8(lPort_8, 1, mod_motor_set_brake_3b)
    JR_EQ8(lPort_8, 2, mod_motor_set_brake_3c)
    JR_EQ8(lPort_8, 3, mod_motor_set_brake_3d)
    RETURN()
mod_motor_set_brake_3a:
    MOVE8_8(lBrake_8, gModMotor3ABrake_8)
    RETURN()
mod_motor_set_brake_3b:
    MOVE8_8(lBrake_8, gModMotor3BBrake_8)
    RETURN()
mod_motor_set_brake_3c:
    MOVE8_8(lBrake_8, gModMotor3CBrake_8)
    RETURN()
mod_motor_set_brake_3d:
    MOVE8_8(lBrake_8, gModMotor3DBrake_8)
    RETURN()

mod_motor_set_brake_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_set_brake_4a)
    JR_EQ8(lPort_8, 1, mod_motor_set_brake_4b)
    JR_EQ8(lPort_8, 2, mod_motor_set_brake_4c)
    JR_EQ8(lPort_8, 3, mod_motor_set_brake_4d)
    RETURN()
mod_motor_set_brake_4a:
    MOVE8_8(lBrake_8, gModMotor4ABrake_8)
    RETURN()
mod_motor_set_brake_4b:
    MOVE8_8(lBrake_8, gModMotor4BBrake_8)
    RETURN()
mod_motor_set_brake_4c:
    MOVE8_8(lBrake_8, gModMotor4CBrake_8)
    RETURN()
mod_motor_set_brake_4d:
    MOVE8_8(lBrake_8, gModMotor4DBrake_8)
    RETURN()
}

subcall modMotorGetType {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8
    DATA8 lType_8
    DATA8 lMode_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    ADD8(lPort_8, 16, lPort_8)
    INPUT_DEVICE(GET_TYPEMODE, lLayer_8, lPort_8, lType_8, lMode_8)

    CALL(setRet8AndKeep, lType_8)
}

subcall modMotorReset {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    JR_EQ8(lLayer_8, 0, mod_motor_reset_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_reset_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_reset_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_reset_layer4)
    RETURN()

mod_motor_reset_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_reset_1a)
    JR_EQ8(lPort_8, 1, mod_motor_reset_1b)
    JR_EQ8(lPort_8, 2, mod_motor_reset_1c)
    JR_EQ8(lPort_8, 3, mod_motor_reset_1d)
    RETURN()
mod_motor_reset_1a:
    CALL(modMotorResetMotor, 0, 101)
    MOVE32_32(0, gModMotor1ACurrrent_32)
    MOVE32_32(0, gModMotor1ATarget_32)
    RETURN()
mod_motor_reset_1b:
    CALL(modMotorResetMotor, 0, 102)
    MOVE32_32(0, gModMotor1BCurrrent_32)
    MOVE32_32(0, gModMotor1BTarget_32)
    RETURN()
mod_motor_reset_1c:
    CALL(modMotorResetMotor, 0, 103)
    MOVE32_32(0, gModMotor1CCurrrent_32)
    MOVE32_32(0, gModMotor1CTarget_32)
    RETURN()
mod_motor_reset_1d:
    CALL(modMotorResetMotor, 0, 104)
    MOVE32_32(0, gModMotor1DCurrrent_32)
    MOVE32_32(0, gModMotor1DTarget_32)
    RETURN()

mod_motor_reset_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_reset_2a)
    JR_EQ8(lPort_8, 1, mod_motor_reset_2b)
    JR_EQ8(lPort_8, 2, mod_motor_reset_2c)
    JR_EQ8(lPort_8, 3, mod_motor_reset_2d)
    RETURN()
mod_motor_reset_2a:
    CALL(modMotorResetMotor, 1, 101)
    MOVE32_32(0, gModMotor2ACurrrent_32)
    MOVE32_32(0, gModMotor2ATarget_32)
    RETURN()
mod_motor_reset_2b:
    CALL(modMotorResetMotor, 1, 102)
    MOVE32_32(0, gModMotor2BCurrrent_32)
    MOVE32_32(0, gModMotor2BTarget_32)
    RETURN()
mod_motor_reset_2c:
    CALL(modMotorResetMotor, 1, 103)
    MOVE32_32(0, gModMotor2CCurrrent_32)
    MOVE32_32(0, gModMotor2CTarget_32)
    RETURN()
mod_motor_reset_2d:
    CALL(modMotorResetMotor, 1, 104)
    MOVE32_32(0, gModMotor2DCurrrent_32)
    MOVE32_32(0, gModMotor2DTarget_32)
    RETURN()

mod_motor_reset_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_reset_3a)
    JR_EQ8(lPort_8, 1, mod_motor_reset_3b)
    JR_EQ8(lPort_8, 2, mod_motor_reset_3c)
    JR_EQ8(lPort_8, 3, mod_motor_reset_3d)
    RETURN()
mod_motor_reset_3a:
    CALL(modMotorResetMotor, 2, 101)
    MOVE32_32(0, gModMotor3ACurrrent_32)
    MOVE32_32(0, gModMotor3ATarget_32)
    RETURN()
mod_motor_reset_3b:
    CALL(modMotorResetMotor, 2, 102)
    MOVE32_32(0, gModMotor3BCurrrent_32)
    MOVE32_32(0, gModMotor3BTarget_32)
    RETURN()
mod_motor_reset_3c:
    CALL(modMotorResetMotor, 2, 103)
    MOVE32_32(0, gModMotor3CCurrrent_32)
    MOVE32_32(0, gModMotor3CTarget_32)
    RETURN()
mod_motor_reset_3d:
    CALL(modMotorResetMotor, 2, 104)
    MOVE32_32(0, gModMotor3DCurrrent_32)
    MOVE32_32(0, gModMotor3DTarget_32)
    RETURN()

mod_motor_reset_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_reset_4a)
    JR_EQ8(lPort_8, 1, mod_motor_reset_4b)
    JR_EQ8(lPort_8, 2, mod_motor_reset_4c)
    JR_EQ8(lPort_8, 3, mod_motor_reset_4d)
    RETURN()
mod_motor_reset_4a:
    CALL(modMotorResetMotor, 3, 101)
    MOVE32_32(0, gModMotor4ACurrrent_32)
    MOVE32_32(0, gModMotor4ATarget_32)
    RETURN()
mod_motor_reset_4b:
    CALL(modMotorResetMotor, 3, 102)
    MOVE32_32(0, gModMotor4BCurrrent_32)
    MOVE32_32(0, gModMotor4BTarget_32)
    RETURN()
mod_motor_reset_4c:
    CALL(modMotorResetMotor, 3, 103)
    MOVE32_32(0, gModMotor4CCurrrent_32)
    MOVE32_32(0, gModMotor4CTarget_32)
    RETURN()
mod_motor_reset_4d:
    CALL(modMotorResetMotor, 3, 104)
    MOVE32_32(0, gModMotor4DCurrrent_32)
    MOVE32_32(0, gModMotor4DTarget_32)
    RETURN()
}

subcall modMotorMoveTo {
    IN_32  pRegSrc_32
    DATA8  lLayer_8
    DATA8  lPort_8
    DATA32 lTarget_32

    CALL(readMem8,  pRegSrc_32, 0, lLayer_8)
    CALL(readMem8,  pRegSrc_32, 1, lPort_8)
    CALL(readMem32, pRegSrc_32, 2, lTarget_32)

    JR_EQ8(lLayer_8, 0, mod_motor_move_to_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_move_to_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_move_to_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_move_to_layer4)
    RETURN()

mod_motor_move_to_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_move_to_1a)
    JR_EQ8(lPort_8, 1, mod_motor_move_to_1b)
    JR_EQ8(lPort_8, 2, mod_motor_move_to_1c)
    JR_EQ8(lPort_8, 3, mod_motor_move_to_1d)
    RETURN()
mod_motor_move_to_1a:
    CALL(startThread1A)
    MOVE8_8(2, gModMotor1AMode_8)
    MOVE32_32(lTarget_32, gModMotor1ATarget_32)
    RETURN()
mod_motor_move_to_1b:
    CALL(startThread1B)
    MOVE8_8(2, gModMotor1BMode_8)
    MOVE32_32(lTarget_32, gModMotor1BTarget_32)
    RETURN()
mod_motor_move_to_1c:
    CALL(startThread1C)
    MOVE8_8(2, gModMotor1CMode_8)
    MOVE32_32(lTarget_32, gModMotor1CTarget_32)
    RETURN()
mod_motor_move_to_1d:
    CALL(startThread1D)
    MOVE8_8(2, gModMotor1DMode_8)
    MOVE32_32(lTarget_32, gModMotor1DTarget_32)
    RETURN()

mod_motor_move_to_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_move_to_2a)
    JR_EQ8(lPort_8, 1, mod_motor_move_to_2b)
    JR_EQ8(lPort_8, 2, mod_motor_move_to_2c)
    JR_EQ8(lPort_8, 3, mod_motor_move_to_2d)
    RETURN()
mod_motor_move_to_2a:
    CALL(startThread2A)
    MOVE8_8(2, gModMotor2AMode_8)
    MOVE32_32(lTarget_32, gModMotor2ATarget_32)
    RETURN()
mod_motor_move_to_2b:
    CALL(startThread2B)
    MOVE8_8(2, gModMotor2BMode_8)
    MOVE32_32(lTarget_32, gModMotor2BTarget_32)
    RETURN()
mod_motor_move_to_2c:
    CALL(startThread2C)
    MOVE8_8(2, gModMotor2CMode_8)
    MOVE32_32(lTarget_32, gModMotor2CTarget_32)
    RETURN()
mod_motor_move_to_2d:
    CALL(startThread2D)
    MOVE8_8(2, gModMotor2DMode_8)
    MOVE32_32(lTarget_32, gModMotor2DTarget_32)
    RETURN()

mod_motor_move_to_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_move_to_3a)
    JR_EQ8(lPort_8, 1, mod_motor_move_to_3b)
    JR_EQ8(lPort_8, 2, mod_motor_move_to_3c)
    JR_EQ8(lPort_8, 3, mod_motor_move_to_3d)
    RETURN()
mod_motor_move_to_3a:
    CALL(startThread3A)
    MOVE8_8(2, gModMotor3AMode_8)
    MOVE32_32(lTarget_32, gModMotor3ATarget_32)
    RETURN()
mod_motor_move_to_3b:
    CALL(startThread3B)
    MOVE8_8(2, gModMotor3BMode_8)
    MOVE32_32(lTarget_32, gModMotor3BTarget_32)
    RETURN()
mod_motor_move_to_3c:
    CALL(startThread3C)
    MOVE8_8(2, gModMotor3CMode_8)
    MOVE32_32(lTarget_32, gModMotor3CTarget_32)
    RETURN()
mod_motor_move_to_3d:
    CALL(startThread3D)
    MOVE8_8(2, gModMotor3DMode_8)
    MOVE32_32(lTarget_32, gModMotor3DTarget_32)
    RETURN()

mod_motor_move_to_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_move_to_4a)
    JR_EQ8(lPort_8, 1, mod_motor_move_to_4b)
    JR_EQ8(lPort_8, 2, mod_motor_move_to_4c)
    JR_EQ8(lPort_8, 3, mod_motor_move_to_4d)
    RETURN()
mod_motor_move_to_4a:
    CALL(startThread4A)
    MOVE8_8(2, gModMotor4AMode_8)
    MOVE32_32(lTarget_32, gModMotor4ATarget_32)
    RETURN()
mod_motor_move_to_4b:
    CALL(startThread4B)
    MOVE8_8(2, gModMotor4BMode_8)
    MOVE32_32(lTarget_32, gModMotor4BTarget_32)
    RETURN()
mod_motor_move_to_4c:
    CALL(startThread4C)
    MOVE8_8(2, gModMotor4CMode_8)
    MOVE32_32(lTarget_32, gModMotor4CTarget_32)
    RETURN()
mod_motor_move_to_4d:
    CALL(startThread4D)
    MOVE8_8(2, gModMotor4DMode_8)
    MOVE32_32(lTarget_32, gModMotor4DTarget_32)
    RETURN()
}

subcall modMotorOn {
    IN_32  pRegSrc_32
    DATA8  lLayer_8
    DATA8  lPort_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    JR_EQ8(lLayer_8, 0, mod_motor_on_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_on_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_on_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_on_layer4)
    RETURN()

mod_motor_on_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_on_1a)
    JR_EQ8(lPort_8, 1, mod_motor_on_1b)
    JR_EQ8(lPort_8, 2, mod_motor_on_1c)
    JR_EQ8(lPort_8, 3, mod_motor_on_1d)
    RETURN()
mod_motor_on_1a:
    MOVE8_8(0, gModMotor1AMode_8)
    CALL(modMotorOnMotor, 0, 101, gModMotor1ASpeed_8)
    RETURN()
mod_motor_on_1b:
    MOVE8_8(0, gModMotor1AMode_8)
    CALL(modMotorOnMotor, 0, 102, gModMotor1BSpeed_8)
    RETURN()
mod_motor_on_1c:
    MOVE8_8(0, gModMotor1AMode_8)
    CALL(modMotorOnMotor, 0, 103, gModMotor1CSpeed_8)
    RETURN()
mod_motor_on_1d:
    MOVE8_8(0, gModMotor1AMode_8)
    CALL(modMotorOnMotor, 0, 104, gModMotor1DSpeed_8)
    RETURN()

mod_motor_on_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_on_2a)
    JR_EQ8(lPort_8, 1, mod_motor_on_2b)
    JR_EQ8(lPort_8, 2, mod_motor_on_2c)
    JR_EQ8(lPort_8, 3, mod_motor_on_2d)
    RETURN()
mod_motor_on_2a:
    MOVE8_8(0, gModMotor2AMode_8)
    CALL(modMotorOnMotor, 1, 101, gModMotor2ASpeed_8)
    RETURN()
mod_motor_on_2b:
    MOVE8_8(0, gModMotor2AMode_8)
    CALL(modMotorOnMotor, 1, 102, gModMotor2BSpeed_8)
    RETURN()
mod_motor_on_2c:
    MOVE8_8(0, gModMotor2AMode_8)
    CALL(modMotorOnMotor, 1, 103, gModMotor2CSpeed_8)
    RETURN()
mod_motor_on_2d:
    MOVE8_8(0, gModMotor2AMode_8)
    CALL(modMotorOnMotor, 1, 104, gModMotor2DSpeed_8)
    RETURN()

mod_motor_on_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_on_3a)
    JR_EQ8(lPort_8, 1, mod_motor_on_3b)
    JR_EQ8(lPort_8, 2, mod_motor_on_3c)
    JR_EQ8(lPort_8, 3, mod_motor_on_3d)
    RETURN()
mod_motor_on_3a:
    MOVE8_8(0, gModMotor3AMode_8)
    CALL(modMotorOnMotor, 2, 101, gModMotor3ASpeed_8)
    RETURN()
mod_motor_on_3b:
    MOVE8_8(0, gModMotor3AMode_8)
    CALL(modMotorOnMotor, 2, 102, gModMotor3BSpeed_8)
    RETURN()
mod_motor_on_3c:
    MOVE8_8(0, gModMotor3AMode_8)
    CALL(modMotorOnMotor, 2, 103, gModMotor3CSpeed_8)
    RETURN()
mod_motor_on_3d:
    MOVE8_8(0, gModMotor3AMode_8)
    CALL(modMotorOnMotor, 2, 104, gModMotor3DSpeed_8)
    RETURN()

mod_motor_on_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_on_4a)
    JR_EQ8(lPort_8, 1, mod_motor_on_4b)
    JR_EQ8(lPort_8, 2, mod_motor_on_4c)
    JR_EQ8(lPort_8, 3, mod_motor_on_4d)
    RETURN()
mod_motor_on_4a:
    MOVE8_8(0, gModMotor4AMode_8)
    CALL(modMotorOnMotor, 3, 101, gModMotor4ASpeed_8)
    RETURN()
mod_motor_on_4b:
    MOVE8_8(0, gModMotor4AMode_8)
    CALL(modMotorOnMotor, 3, 102, gModMotor4BSpeed_8)
    RETURN()
mod_motor_on_4c:
    MOVE8_8(0, gModMotor4AMode_8)
    CALL(modMotorOnMotor, 3, 103, gModMotor4CSpeed_8)
    RETURN()
mod_motor_on_4d:
    MOVE8_8(0, gModMotor4AMode_8)
    CALL(modMotorOnMotor, 3, 104, gModMotor4DSpeed_8)
    RETURN()
}

subcall modMotorTimeOn {
    IN_32  pRegSrc_32
    DATA8  lLayer_8
    DATA8  lPort_8
    DATA32 lTime_32

    CALL(readMem8,  pRegSrc_32, 0, lLayer_8)
    CALL(readMem8,  pRegSrc_32, 1, lPort_8)
    CALL(readMem32, pRegSrc_32, 1, lTime_32)

    JR_EQ8(lLayer_8, 0, mod_motor_time_on_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_time_on_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_time_on_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_time_on_layer4)
    RETURN()

mod_motor_time_on_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_time_on_1a)
    JR_EQ8(lPort_8, 1, mod_motor_time_on_1b)
    JR_EQ8(lPort_8, 2, mod_motor_time_on_1c)
    JR_EQ8(lPort_8, 3, mod_motor_time_on_1d)
    RETURN()
mod_motor_time_on_1a:
    CALL(startThread1A)
    MOVE32_32(lTime_32, gModMotor1ATime_32)
    MOVE8_8(2, gModMotor1AMode_8)
    RETURN()
mod_motor_time_on_1b:
    CALL(startThread1B)
    MOVE32_32(lTime_32, gModMotor1BTime_32)
    MOVE8_8(2, gModMotor1BMode_8)
    RETURN()
mod_motor_time_on_1c:
    CALL(startThread1C)
    MOVE32_32(lTime_32, gModMotor1CTime_32)
    MOVE8_8(2, gModMotor1CMode_8)
    RETURN()
mod_motor_time_on_1d:
    CALL(startThread1D)
    MOVE32_32(lTime_32, gModMotor1DTime_32)
    MOVE8_8(2, gModMotor1DMode_8)
    RETURN()

mod_motor_time_on_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_time_on_2a)
    JR_EQ8(lPort_8, 1, mod_motor_time_on_2b)
    JR_EQ8(lPort_8, 2, mod_motor_time_on_2c)
    JR_EQ8(lPort_8, 3, mod_motor_time_on_2d)
    RETURN()
mod_motor_time_on_2a:
    CALL(startThread2A)
    MOVE32_32(lTime_32, gModMotor2ATime_32)
    MOVE8_8(2, gModMotor2AMode_8)
    RETURN()
mod_motor_time_on_2b:
    CALL(startThread2B)
    MOVE32_32(lTime_32, gModMotor2BTime_32)
    MOVE8_8(2, gModMotor2BMode_8)
    RETURN()
mod_motor_time_on_2c:
    CALL(startThread2C)
    MOVE32_32(lTime_32, gModMotor2CTime_32)
    MOVE8_8(2, gModMotor2CMode_8)
    RETURN()
mod_motor_time_on_2d:
    CALL(startThread2D)
    MOVE32_32(lTime_32, gModMotor2DTime_32)
    MOVE8_8(2, gModMotor2DMode_8)
    RETURN()

mod_motor_time_on_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_time_on_3a)
    JR_EQ8(lPort_8, 1, mod_motor_time_on_3b)
    JR_EQ8(lPort_8, 2, mod_motor_time_on_3c)
    JR_EQ8(lPort_8, 3, mod_motor_time_on_3d)
    RETURN()
mod_motor_time_on_3a:
    CALL(startThread3A)
    MOVE32_32(lTime_32, gModMotor3ATime_32)
    MOVE8_8(2, gModMotor3AMode_8)
    RETURN()
mod_motor_time_on_3b:
    CALL(startThread3B)
    MOVE32_32(lTime_32, gModMotor3BTime_32)
    MOVE8_8(2, gModMotor3BMode_8)
    RETURN()
mod_motor_time_on_3c:
    CALL(startThread3C)
    MOVE32_32(lTime_32, gModMotor3CTime_32)
    MOVE8_8(2, gModMotor3CMode_8)
    RETURN()
mod_motor_time_on_3d:
    CALL(startThread3D)
    MOVE32_32(lTime_32, gModMotor3DTime_32)
    MOVE8_8(2, gModMotor3DMode_8)
    RETURN()

mod_motor_time_on_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_time_on_4a)
    JR_EQ8(lPort_8, 1, mod_motor_time_on_4b)
    JR_EQ8(lPort_8, 2, mod_motor_time_on_4c)
    JR_EQ8(lPort_8, 3, mod_motor_time_on_4d)
    RETURN()
mod_motor_time_on_4a:
    CALL(startThread4A)
    MOVE32_32(lTime_32, gModMotor4ATime_32)
    MOVE8_8(2, gModMotor4AMode_8)
    RETURN()
mod_motor_time_on_4b:
    CALL(startThread4B)
    MOVE32_32(lTime_32, gModMotor4BTime_32)
    MOVE8_8(2, gModMotor4BMode_8)
    RETURN()
mod_motor_time_on_4c:
    CALL(startThread4C)
    MOVE32_32(lTime_32, gModMotor4CTime_32)
    MOVE8_8(2, gModMotor4CMode_8)
    RETURN()
mod_motor_time_on_4d:
    CALL(startThread4D)
    MOVE32_32(lTime_32, gModMotor4DTime_32)
    MOVE8_8(2, gModMotor4DMode_8)
    RETURN()
}

subcall modMotorStop {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    JR_EQ8(lLayer_8, 0, mod_motor_stop_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_stop_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_stop_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_stop_layer4)
    RETURN()

mod_motor_stop_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_stop_1a)
    JR_EQ8(lPort_8, 1, mod_motor_stop_1b)
    JR_EQ8(lPort_8, 2, mod_motor_stop_1c)
    JR_EQ8(lPort_8, 3, mod_motor_stop_1d)
    RETURN()
mod_motor_stop_1a:
    CALL(modMotorStopMotor, 0, 101, gModMotor1ABrake_8)
    CALL(modMotorReadValue, 0, 101, gModMotor1ACurrrent_32)
    MOVE8_8(0, gModMotor1AMode_8)
    RETURN()
mod_motor_stop_1b:
    CALL(modMotorStopMotor, 0, 102, gModMotor1BBrake_8)
    CALL(modMotorReadValue, 0, 102, gModMotor1BCurrrent_32)
    MOVE8_8(0, gModMotor1BMode_8)
    RETURN()
mod_motor_stop_1c:
    CALL(modMotorStopMotor, 0, 103, gModMotor1CBrake_8)
    CALL(modMotorReadValue, 0, 103, gModMotor1CCurrrent_32)
    MOVE8_8(0, gModMotor1CMode_8)
    RETURN()
mod_motor_stop_1d:
    CALL(modMotorStopMotor, 0, 104, gModMotor1DBrake_8)
    CALL(modMotorReadValue, 0, 104, gModMotor1DCurrrent_32)
    MOVE8_8(0, gModMotor1DMode_8)
    RETURN()

mod_motor_stop_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_stop_2a)
    JR_EQ8(lPort_8, 1, mod_motor_stop_2b)
    JR_EQ8(lPort_8, 2, mod_motor_stop_2c)
    JR_EQ8(lPort_8, 3, mod_motor_stop_2d)
    RETURN()
mod_motor_stop_2a:
    CALL(modMotorStopMotor, 0, 101, gModMotor2ABrake_8)
    CALL(modMotorReadValue, 0, 101, gModMotor2ACurrrent_32)
    MOVE8_8(0, gModMotor2AMode_8)
    RETURN()
mod_motor_stop_2b:
    CALL(modMotorStopMotor, 0, 102, gModMotor2BBrake_8)
    CALL(modMotorReadValue, 0, 102, gModMotor2BCurrrent_32)
    MOVE8_8(0, gModMotor2BMode_8)
    RETURN()
mod_motor_stop_2c:
    CALL(modMotorStopMotor, 0, 103, gModMotor2CBrake_8)
    CALL(modMotorReadValue, 0, 103, gModMotor2CCurrrent_32)
    MOVE8_8(0, gModMotor2CMode_8)
    RETURN()
mod_motor_stop_2d:
    CALL(modMotorStopMotor, 0, 104, gModMotor2DBrake_8)
    CALL(modMotorReadValue, 0, 104, gModMotor2DCurrrent_32)
    MOVE8_8(0, gModMotor2DMode_8)
    RETURN()

mod_motor_stop_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_stop_3a)
    JR_EQ8(lPort_8, 1, mod_motor_stop_3b)
    JR_EQ8(lPort_8, 2, mod_motor_stop_3c)
    JR_EQ8(lPort_8, 3, mod_motor_stop_3d)
    RETURN()
mod_motor_stop_3a:
    CALL(modMotorStopMotor, 0, 101, gModMotor3ABrake_8)
    CALL(modMotorReadValue, 0, 101, gModMotor3ACurrrent_32)
    MOVE8_8(0, gModMotor1AMode_8)
    RETURN()
mod_motor_stop_3b:
    CALL(modMotorStopMotor, 0, 102, gModMotor3BBrake_8)
    CALL(modMotorReadValue, 0, 102, gModMotor3BCurrrent_32)
    MOVE8_8(0, gModMotor1BMode_8)
    RETURN()
mod_motor_stop_3c:
    CALL(modMotorStopMotor, 0, 103, gModMotor3CBrake_8)
    CALL(modMotorReadValue, 0, 103, gModMotor3CCurrrent_32)
    MOVE8_8(0, gModMotor1CMode_8)
    RETURN()
mod_motor_stop_3d:
    CALL(modMotorStopMotor, 0, 104, gModMotor3DBrake_8)
    CALL(modMotorReadValue, 0, 104, gModMotor3DCurrrent_32)
    MOVE8_8(0, gModMotor1DMode_8)
    RETURN()

mod_motor_stop_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_stop_4a)
    JR_EQ8(lPort_8, 1, mod_motor_stop_4b)
    JR_EQ8(lPort_8, 2, mod_motor_stop_4c)
    JR_EQ8(lPort_8, 3, mod_motor_stop_4d)
    RETURN()
mod_motor_stop_4a:
    CALL(modMotorStopMotor, 0, 101, gModMotor4ABrake_8)
    CALL(modMotorReadValue, 0, 101, gModMotor4ACurrrent_32)
    MOVE8_8(0, gModMotor4AMode_8)
    RETURN()
mod_motor_stop_4b:
    CALL(modMotorStopMotor, 0, 102, gModMotor4BBrake_8)
    CALL(modMotorReadValue, 0, 102, gModMotor4BCurrrent_32)
    MOVE8_8(0, gModMotor4BMode_8)
    RETURN()
mod_motor_stop_4c:
    CALL(modMotorStopMotor, 0, 103, gModMotor4CBrake_8)
    CALL(modMotorReadValue, 0, 103, gModMotor4CCurrrent_32)
    MOVE8_8(0, gModMotor4CMode_8)
    RETURN()
mod_motor_stop_4d:
    CALL(modMotorStopMotor, 0, 104, gModMotor4DBrake_8)
    CALL(modMotorReadValue, 0, 104, gModMotor4DCurrrent_32)
    MOVE8_8(0, gModMotor4DMode_8)
    RETURN()
}

subcall modMotorRead {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    JR_EQ8(lLayer_8, 0, mod_motor_read_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_read_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_read_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_read_layer4)
    RETURN()

mod_motor_read_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_read_1a)
    JR_EQ8(lPort_8, 1, mod_motor_read_1b)
    JR_EQ8(lPort_8, 2, mod_motor_read_1c)
    JR_EQ8(lPort_8, 3, mod_motor_read_1d)
    RETURN()
mod_motor_read_1a:
    CALL(modMotorReadValue, 0, 101, gModMotor1ACurrrent_32)
    CALL(setRet32AndKeep, gModMotor1ACurrrent_32)
    RETURN()
mod_motor_read_1b:
    CALL(modMotorReadValue, 0, 102, gModMotor1BCurrrent_32)
    CALL(setRet32AndKeep, gModMotor1BCurrrent_32)
    RETURN()
mod_motor_read_1c:
    CALL(modMotorReadValue, 0, 103, gModMotor1CCurrrent_32)
    CALL(setRet32AndKeep, gModMotor1CCurrrent_32)
    RETURN()
mod_motor_read_1d:
    CALL(modMotorReadValue, 0, 104, gModMotor1DCurrrent_32)
    CALL(setRet32AndKeep, gModMotor1DCurrrent_32)
    RETURN()

mod_motor_read_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_read_2a)
    JR_EQ8(lPort_8, 1, mod_motor_read_2b)
    JR_EQ8(lPort_8, 2, mod_motor_read_2c)
    JR_EQ8(lPort_8, 3, mod_motor_read_2d)
    RETURN()
mod_motor_read_2a:
    CALL(modMotorReadValue, 1, 101, gModMotor2ACurrrent_32)
    CALL(setRet32AndKeep, gModMotor2ACurrrent_32)
    RETURN()
mod_motor_read_2b:
    CALL(modMotorReadValue, 1, 102, gModMotor2BCurrrent_32)
    CALL(setRet32AndKeep, gModMotor2BCurrrent_32)
    RETURN()
mod_motor_read_2c:
    CALL(modMotorReadValue, 1, 103, gModMotor2CCurrrent_32)
    CALL(setRet32AndKeep, gModMotor2CCurrrent_32)
    RETURN()
mod_motor_read_2d:
    CALL(modMotorReadValue, 1, 104, gModMotor2DCurrrent_32)
    CALL(setRet32AndKeep, gModMotor2DCurrrent_32)
    RETURN()

mod_motor_read_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_read_3a)
    JR_EQ8(lPort_8, 1, mod_motor_read_3b)
    JR_EQ8(lPort_8, 2, mod_motor_read_3c)
    JR_EQ8(lPort_8, 3, mod_motor_read_3d)
    RETURN()
mod_motor_read_3a:
    CALL(modMotorReadValue, 2, 101, gModMotor3ACurrrent_32)
    CALL(setRet32AndKeep, gModMotor3ACurrrent_32)
    RETURN()
mod_motor_read_3b:
    CALL(modMotorReadValue, 2, 102, gModMotor3BCurrrent_32)
    CALL(setRet32AndKeep, gModMotor3BCurrrent_32)
    RETURN()
mod_motor_read_3c:
    CALL(modMotorReadValue, 2, 103, gModMotor3CCurrrent_32)
    CALL(setRet32AndKeep, gModMotor3CCurrrent_32)
    RETURN()
mod_motor_read_3d:
    CALL(modMotorReadValue, 2, 104, gModMotor3DCurrrent_32)
    CALL(setRet32AndKeep, gModMotor3DCurrrent_32)
    RETURN()

mod_motor_read_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_read_4a)
    JR_EQ8(lPort_8, 1, mod_motor_read_4b)
    JR_EQ8(lPort_8, 2, mod_motor_read_4c)
    JR_EQ8(lPort_8, 3, mod_motor_read_4d)
    RETURN()
mod_motor_read_4a:
    CALL(modMotorReadValue, 3, 101, gModMotor4ACurrrent_32)
    CALL(setRet32AndKeep, gModMotor4ACurrrent_32)
    RETURN()
mod_motor_read_4b:
    CALL(modMotorReadValue, 3, 102, gModMotor4BCurrrent_32)
    CALL(setRet32AndKeep, gModMotor4BCurrrent_32)
    RETURN()
mod_motor_read_4c:
    CALL(modMotorReadValue, 3, 103, gModMotor4CCurrrent_32)
    CALL(setRet32AndKeep, gModMotor4CCurrrent_32)
    RETURN()
mod_motor_read_4d:
    CALL(modMotorReadValue, 3, 104, gModMotor4DCurrrent_32)
    CALL(setRet32AndKeep, gModMotor4DCurrrent_32)
    RETURN()
}

subcall modMotorReady {
    IN_32 pRegSrc_32
    DATA8 lLayer_8
    DATA8 lPort_8

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    JR_EQ8(lLayer_8, 0, mod_motor_ready_layer1)
    JR_EQ8(lLayer_8, 1, mod_motor_ready_layer2)
    JR_EQ8(lLayer_8, 2, mod_motor_ready_layer3)
    JR_EQ8(lLayer_8, 3, mod_motor_ready_layer4)
    RETURN()

mod_motor_ready_layer1:
    JR_EQ8(lPort_8, 0, mod_motor_ready_1a)
    JR_EQ8(lPort_8, 1, mod_motor_ready_1b)
    JR_EQ8(lPort_8, 2, mod_motor_ready_1c)
    JR_EQ8(lPort_8, 3, mod_motor_ready_1d)
    RETURN()
mod_motor_ready_1a:
    CALL(setRet8AndKeep, gModMotor1AReady_8)
    RETURN()
mod_motor_ready_1b:
    CALL(setRet8AndKeep, gModMotor1BReady_8)
    RETURN()
mod_motor_ready_1c:
    CALL(setRet8AndKeep, gModMotor1CReady_8)
    RETURN()
mod_motor_ready_1d:
    CALL(setRet8AndKeep, gModMotor1DReady_8)
    RETURN()

mod_motor_ready_layer2:
    JR_EQ8(lPort_8, 0, mod_motor_ready_2a)
    JR_EQ8(lPort_8, 1, mod_motor_ready_2b)
    JR_EQ8(lPort_8, 2, mod_motor_ready_2c)
    JR_EQ8(lPort_8, 3, mod_motor_ready_2d)
    RETURN()
mod_motor_ready_2a:
    CALL(setRet8AndKeep, gModMotor2AReady_8)
    RETURN()
mod_motor_ready_2b:
    CALL(setRet8AndKeep, gModMotor2BReady_8)
    RETURN()
mod_motor_ready_2c:
    CALL(setRet8AndKeep, gModMotor2CReady_8)
    RETURN()
mod_motor_ready_2d:
    CALL(setRet8AndKeep, gModMotor2DReady_8)
    RETURN()

mod_motor_ready_layer3:
    JR_EQ8(lPort_8, 0, mod_motor_ready_3a)
    JR_EQ8(lPort_8, 1, mod_motor_ready_3b)
    JR_EQ8(lPort_8, 2, mod_motor_ready_3c)
    JR_EQ8(lPort_8, 3, mod_motor_ready_3d)
    RETURN()
mod_motor_ready_3a:
    CALL(setRet8AndKeep, gModMotor3AReady_8)
    RETURN()
mod_motor_ready_3b:
    CALL(setRet8AndKeep, gModMotor3BReady_8)
    RETURN()
mod_motor_ready_3c:
    CALL(setRet8AndKeep, gModMotor3CReady_8)
    RETURN()
mod_motor_ready_3d:
    CALL(setRet8AndKeep, gModMotor3DReady_8)
    RETURN()

mod_motor_ready_layer4:
    JR_EQ8(lPort_8, 0, mod_motor_ready_4a)
    JR_EQ8(lPort_8, 1, mod_motor_ready_4b)
    JR_EQ8(lPort_8, 2, mod_motor_ready_4c)
    JR_EQ8(lPort_8, 3, mod_motor_ready_4d)
    RETURN()
mod_motor_ready_4a:
    CALL(setRet8AndKeep, gModMotor4AReady_8)
    RETURN()
mod_motor_ready_4b:
    CALL(setRet8AndKeep, gModMotor4BReady_8)
    RETURN()
mod_motor_ready_4c:
    CALL(setRet8AndKeep, gModMotor4CReady_8)
    RETURN()
mod_motor_ready_4d:
    CALL(setRet8AndKeep, gModMotor4DReady_8)
    RETURN()
}

subcall modMotorResetMotor {
    IN_8   pLayer_8
    IN_32  pPort_32
    DATA8  lBitfield_8
    DATA8  lInverted_8
    DATA32 lPort_32

    PORT_CNV_OUTPUT(pPort_32, pLayer_8, lBitfield_8, lInverted_8)
    OUTPUT_CLR_COUNT(pLayer_8, lBitfield_8)
}

subcall modMotorStopMotor {
    IN_8   pLayer_8
    IN_32  pPort_32
    IN_8   pBrake_8
    DATA8  lBitfield_8
    DATA8  lInverted_8

    PORT_CNV_OUTPUT(pPort_32, pLayer_8, lBitfield_8, lInverted_8)
    OUTPUT_STOP(pLayer_8, lBitfield_8, pBrake_8)
}

subcall modMotorReadValue {
    IN_8   pLayer_8
    IN_32  pPort_32
    OUT_32 pMotorPos_32
    DATA8  lBitfield_8

    PORT_CNV_INPUT(pPort_32, pLayer_8, lBitfield_8)
    OUTPUT_GET_COUNT(pLayer_8, lBitfield_8, pMotorPos_32)
}

subcall modMotorOnMotor {
    IN_8   pLayer_8
    IN_32  pPort_32
    IN_8   pSpeed_8
    DATA8  lBitfield_8
    DATA8  lInverted_8

    PORT_CNV_OUTPUT(pPort_32, pLayer_8, lBitfield_8, lInverted_8)
    OUTPUT_SPEED(pLayer_8, lBitfield_8, pSpeed_8)
    OUTPUT_START(pLayer_8, lBitfield_8)
}

//=================================================================================================//
//
// File: vm/modMotor1A.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor1AUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor1a_loop:
    MOVE8_8(1, gModMotor1AReady_8)
    SLEEP()
    JR_EQ8(gModMotor1AMode_8, 1, mod_motor1a_time_on)
    JR_EQ8(gModMotor1AMode_8, 2, mod_motor1a_move_to)
    JR(mod_motor1a_loop)

mod_motor1a_time_on:
    MOVE8_8(0, gModMotor1AReady_8)                                      // Motor 1A no longer ready
    CALL(modMotor1ATimeOn)                                              // Motor 1A time on
    CALL(modMotorReadValue, 0, 101, gModMotor1ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1a_loop)

mod_motor1a_move_to:
    MOVE8_8(0, gModMotor1AReady_8)                                      // Motor 1A no longer ready
    SUB32(gModMotor1ATarget_32, gModMotor1ACurrrent_32, lDelta_32)      // Motor 1A delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor1a_loop)
    CALL(modMotor1AMoveTo, lDelta_32)                                   // Motor 1A move to
    CALL(modMotorReadValue, 0, 101, gModMotor1ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1a_loop)
}

subcall modMotor1AMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor1ASpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor1a_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1a_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor1a_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1a_degrees_positive:

    PORT_CNV_OUTPUT(101, 0, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor1ABrake_8)
mod_motor1a_move_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor1AMode_8, 2, mod_motor1a_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor1a_move_wait_loop)
mod_motor1a_move_done:
    MOVE8_8(0, gModMotor1AMode_8)                                       // Motor 1A mode 0
}

subcall modMotor1ATimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(101, 0, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(0, lBitField_8, gModMotor1ASpeed_8, 0, gModMotor1ATime_32, 0, gModMotor1ABrake_8)
mod_motor1a_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor1AMode_8, 1, mod_motor1a_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor1a_time_wait_loop)
mod_motor1a_time_done:
    MOVE8_8(0, gModMotor1AMode_8)                                       // Motor 1A mode 0
}

//=================================================================================================//
//
// File: vm/modMotor1B.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor1BUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor1b_loop:
    MOVE8_8(1, gModMotor1BReady_8)
    SLEEP()
    JR_EQ8(gModMotor1BMode_8, 1, mod_motor1b_time_on)
    JR_EQ8(gModMotor1BMode_8, 2, mod_motor1b_move_to)
    JR(mod_motor1b_loop)

mod_motor1b_time_on:
    MOVE8_8(0, gModMotor1BReady_8)                                      // Motor 1B no longer ready
    CALL(modMotor1BTimeOn)                                              // Motor 1B time on
    CALL(modMotorReadValue, 0, 102, gModMotor1BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1b_loop)

mod_motor1b_move_to:
    MOVE8_8(0, gModMotor1BReady_8)                                      // Motor 1B no longer ready
    SUB32(gModMotor1BTarget_32, gModMotor1BCurrrent_32, lDelta_32)      // Motor 1B delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor1b_loop)
    CALL(modMotor1BMoveTo, lDelta_32)                                   // Motor 1B move to
    CALL(modMotorReadValue, 0, 102, gModMotor1BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1b_loop)
}

subcall modMotor1BMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor1BSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor1b_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1b_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor1b_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1b_degrees_positive:

    PORT_CNV_OUTPUT(102, 0, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor1BBrake_8)
mod_motor1b_move_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor1BMode_8, 2, mod_motor1b_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor1b_move_wait_loop)
mod_motor1b_move_done:
    MOVE8_8(0, gModMotor1BMode_8)                                       // Motor 1B mode 0
}

subcall modMotor1BTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(102, 0, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(0, lBitField_8, gModMotor1BSpeed_8, 0, gModMotor1BTime_32, 0, gModMotor1BBrake_8)
mod_motor1b_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor1BMode_8, 1, mod_motor1b_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor1b_time_wait_loop)
mod_motor1b_time_done:
    MOVE8_8(0, gModMotor1BMode_8)                                       // Motor 1B mode 0
}

//=================================================================================================//
//
// File: vm/modMotor1C.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor1CUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor1c_loop:
    MOVE8_8(1, gModMotor1CReady_8)
    SLEEP()
    JR_EQ8(gModMotor1CMode_8, 1, mod_motor1c_time_on)
    JR_EQ8(gModMotor1CMode_8, 2, mod_motor1c_move_to)
    JR(mod_motor1c_loop)

mod_motor1c_time_on:
    MOVE8_8(0, gModMotor1CReady_8)                                      // Motor 1C no longer ready
    CALL(modMotor1CTimeOn)                                              // Motor 1C time on
    CALL(modMotorReadValue, 0, 103, gModMotor1CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1c_loop)

mod_motor1c_move_to:
    MOVE8_8(0, gModMotor1CReady_8)                                      // Motor 1C no longer ready
    SUB32(gModMotor1CTarget_32, gModMotor1CCurrrent_32, lDelta_32)      // Motor 1C delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor1c_loop)
    CALL(modMotor1CMoveTo, lDelta_32)                                   // Motor 1C move to
    CALL(modMotorReadValue, 0, 103, gModMotor1CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1c_loop)
}

subcall modMotor1CMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor1CSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor1c_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1c_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor1c_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1c_degrees_positive:

    PORT_CNV_OUTPUT(103, 0, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor1CBrake_8)
mod_motor1c_move_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor1CMode_8, 2, mod_motor1c_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor1c_move_wait_loop)
mod_motor1c_move_done:
    MOVE8_8(0, gModMotor1CMode_8)                                       // Motor 1C mode 0
}

subcall modMotor1CTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(103, 0, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(0, lBitField_8, gModMotor1CSpeed_8, 0, gModMotor1CTime_32, 0, gModMotor1CBrake_8)
mod_motor1c_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor1CMode_8, 1, mod_motor1c_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor1c_time_wait_loop)
mod_motor1c_time_done:
    MOVE8_8(0, gModMotor1CMode_8)                                       // Motor 1C mode 0
}

//=================================================================================================//
//
// File: vm/modMotor1D.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor1DUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor1d_loop:
    MOVE8_8(1, gModMotor1DReady_8)
    SLEEP()
    JR_EQ8(gModMotor1DMode_8, 1, mod_motor1d_time_on)
    JR_EQ8(gModMotor1DMode_8, 2, mod_motor1d_move_to)
    JR(mod_motor1d_loop)

mod_motor1d_time_on:
    MOVE8_8(0, gModMotor1DReady_8)                                      // Motor 1D no longer ready
    CALL(modMotor1DTimeOn)                                              // Motor 1D time on
    CALL(modMotorReadValue, 0, 104, gModMotor1DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1d_loop)

mod_motor1d_move_to:
    MOVE8_8(0, gModMotor1DReady_8)                                      // Motor 1D no longer ready
    SUB32(gModMotor1DTarget_32, gModMotor1DCurrrent_32, lDelta_32)      // Motor 1D delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor1d_loop)
    CALL(modMotor1DMoveTo, lDelta_32)                                   // Motor 1D move to
    CALL(modMotorReadValue, 0, 104, gModMotor1DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor1d_loop)
}

subcall modMotor1DMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor1DSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor1d_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1d_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor1d_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor1d_degrees_positive:

    PORT_CNV_OUTPUT(104, 0, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor1DBrake_8)
mod_motor1d_move_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor1DMode_8, 2, mod_motor1d_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor1d_move_wait_loop)
mod_motor1d_move_done:
    MOVE8_8(0, gModMotor1DMode_8)                                       // Motor 1D mode 0
}

subcall modMotor1DTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(104, 0, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(0, lBitField_8, gModMotor1DSpeed_8, 0, gModMotor1DTime_32, 0, gModMotor1DBrake_8)
mod_motor1d_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor1DMode_8, 1, mod_motor1d_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor1d_time_wait_loop)
mod_motor1d_time_done:
    MOVE8_8(0, gModMotor1DMode_8)                                       // Motor 1D mode 0
}

//=================================================================================================//
//
// File: vm/modMotor2A.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor2AUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor2a_loop:
    MOVE8_8(1, gModMotor2AReady_8)
    SLEEP()
    JR_EQ8(gModMotor2AMode_8, 1, mod_motor2a_time_on)
    JR_EQ8(gModMotor2AMode_8, 2, mod_motor2a_move_to)
    JR(mod_motor2a_loop)

mod_motor2a_time_on:
    MOVE8_8(0, gModMotor2AReady_8)                                      // Motor 2A no longer ready
    CALL(modMotor2ATimeOn)                                              // Motor 2A time on
    CALL(modMotorReadValue, 1, 101, gModMotor2ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2a_loop)

mod_motor2a_move_to:
    MOVE8_8(0, gModMotor2AReady_8)                                      // Motor 2A no longer ready
    SUB32(gModMotor2ATarget_32, gModMotor2ACurrrent_32, lDelta_32)      // Motor 2A delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor2a_loop)
    CALL(modMotor2AMoveTo, lDelta_32)                                   // Motor 2A move to
    CALL(modMotorReadValue, 1, 101, gModMotor2ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2a_loop)
}

subcall modMotor2AMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor2ASpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor2a_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2a_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor2a_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2a_degrees_positive:

    PORT_CNV_OUTPUT(101, 1, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor2ABrake_8)
mod_motor2a_move_wait_loop:
    OUTPUT_TEST(1, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor2AMode_8, 2, mod_motor2a_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor2a_move_wait_loop)
mod_motor2a_move_done:
    MOVE8_8(0, gModMotor2AMode_8)                                       // Motor 2A mode 0
}

subcall modMotor2ATimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(101, 1, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(1, lBitField_8, gModMotor2ASpeed_8, 0, gModMotor2ATime_32, 0, gModMotor2ABrake_8)
mod_motor2a_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor2AMode_8, 1, mod_motor2a_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor2a_time_wait_loop)
mod_motor2a_time_done:
    MOVE8_8(0, gModMotor2AMode_8)                                       // Motor 2A mode 0
}

//=================================================================================================//
//
// File: vm/modMotor2B.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor2BUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor2b_loop:
    MOVE8_8(1, gModMotor2BReady_8)
    SLEEP()
    JR_EQ8(gModMotor2BMode_8, 1, mod_motor2b_time_on)
    JR_EQ8(gModMotor2BMode_8, 2, mod_motor2b_move_to)
    JR(mod_motor2b_loop)

mod_motor2b_time_on:
    MOVE8_8(0, gModMotor2BReady_8)                                      // Motor 2B no longer ready
    CALL(modMotor2BTimeOn)                                              // Motor 2B time on
    CALL(modMotorReadValue, 1, 102, gModMotor2BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2b_loop)

mod_motor2b_move_to:
    MOVE8_8(0, gModMotor2BReady_8)                                      // Motor 2B no longer ready
    SUB32(gModMotor2BTarget_32, gModMotor2BCurrrent_32, lDelta_32)      // Motor 2B delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor2b_loop)
    CALL(modMotor2BMoveTo, lDelta_32)                                   // Motor 2B move to
    CALL(modMotorReadValue, 1, 102, gModMotor2BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2b_loop)
}

subcall modMotor2BMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor2BSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor2b_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2b_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor2b_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2b_degrees_positive:

    PORT_CNV_OUTPUT(102, 1, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor2BBrake_8)
mod_motor2b_move_wait_loop:
    OUTPUT_TEST(1, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor2BMode_8, 2, mod_motor2b_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor2b_move_wait_loop)
mod_motor2b_move_done:
    MOVE8_8(0, gModMotor2BMode_8)                                       // Motor 2B mode 0
}

subcall modMotor2BTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(102, 1, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(1, lBitField_8, gModMotor2BSpeed_8, 0, gModMotor2BTime_32, 0, gModMotor2BBrake_8)
mod_motor2b_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor2BMode_8, 1, mod_motor2b_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor2b_time_wait_loop)
mod_motor2b_time_done:
    MOVE8_8(0, gModMotor2BMode_8)                                       // Motor 2B mode 0
}

//=================================================================================================//
//
// File: vm/modMotor2C.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor2CUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor2c_loop:
    MOVE8_8(1, gModMotor2CReady_8)
    SLEEP()
    JR_EQ8(gModMotor2CMode_8, 1, mod_motor2c_time_on)
    JR_EQ8(gModMotor2CMode_8, 2, mod_motor2c_move_to)
    JR(mod_motor2c_loop)

mod_motor2c_time_on:
    MOVE8_8(0, gModMotor2CReady_8)                                      // Motor 2C no longer ready
    CALL(modMotor2CTimeOn)                                              // Motor 2C time on
    CALL(modMotorReadValue, 1, 103, gModMotor2CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2c_loop)

mod_motor2c_move_to:
    MOVE8_8(0, gModMotor2CReady_8)                                      // Motor 2C no longer ready
    SUB32(gModMotor2CTarget_32, gModMotor2CCurrrent_32, lDelta_32)      // Motor 2C delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor2c_loop)
    CALL(modMotor2CMoveTo, lDelta_32)                                   // Motor 2C move to
    CALL(modMotorReadValue, 1, 103, gModMotor2CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2c_loop)
}

subcall modMotor2CMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor2CSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor2c_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2c_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor2c_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2c_degrees_positive:

    PORT_CNV_OUTPUT(103, 1, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor2CBrake_8)
mod_motor2c_move_wait_loop:
    OUTPUT_TEST(1, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor2CMode_8, 2, mod_motor2c_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor2c_move_wait_loop)
mod_motor2c_move_done:
    MOVE8_8(0, gModMotor2CMode_8)                                       // Motor 2C mode 0
}

subcall modMotor2CTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(103, 1, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(1, lBitField_8, gModMotor2CSpeed_8, 0, gModMotor2CTime_32, 0, gModMotor2CBrake_8)
mod_motor2c_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor2CMode_8, 1, mod_motor2c_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor2c_time_wait_loop)
mod_motor2c_time_done:
    MOVE8_8(0, gModMotor2CMode_8)                                       // Motor 2C mode 0
}

//=================================================================================================//
//
// File: vm/modMotor2D.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor2DUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor2d_loop:
    MOVE8_8(1, gModMotor2DReady_8)
    SLEEP()
    JR_EQ8(gModMotor2DMode_8, 1, mod_motor2d_time_on)
    JR_EQ8(gModMotor2DMode_8, 2, mod_motor2d_move_to)
    JR(mod_motor2d_loop)

mod_motor2d_time_on:
    MOVE8_8(0, gModMotor2DReady_8)                                      // Motor 2D no longer ready
    CALL(modMotor2DTimeOn)                                              // Motor 2D time on
    CALL(modMotorReadValue, 1, 104, gModMotor2DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2d_loop)

mod_motor2d_move_to:
    MOVE8_8(0, gModMotor2DReady_8)                                      // Motor 2D no longer ready
    SUB32(gModMotor2DTarget_32, gModMotor2DCurrrent_32, lDelta_32)      // Motor 2D delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor2d_loop)
    CALL(modMotor2DMoveTo, lDelta_32)                                   // Motor 2D move to
    CALL(modMotorReadValue, 1, 104, gModMotor2DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor2d_loop)
}

subcall modMotor2DMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor2DSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor2d_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2d_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor2d_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor2d_degrees_positive:

    PORT_CNV_OUTPUT(104, 1, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor2DBrake_8)
mod_motor2d_move_wait_loop:
    OUTPUT_TEST(1, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor2DMode_8, 2, mod_motor2d_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor2d_move_wait_loop)
mod_motor2d_move_done:
    MOVE8_8(0, gModMotor2DMode_8)                                       // Motor 2D mode 0
}

subcall modMotor2DTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(104, 1, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(1, lBitField_8, gModMotor2DSpeed_8, 0, gModMotor2DTime_32, 0, gModMotor2DBrake_8)
mod_motor2d_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor2DMode_8, 1, mod_motor2d_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor2d_time_wait_loop)
mod_motor2d_time_done:
    MOVE8_8(0, gModMotor2DMode_8)                                       // Motor 2D mode 0
}

//=================================================================================================//
//
// File: vm/modMotor3A.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor3AUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor3a_loop:
    MOVE8_8(1, gModMotor3AReady_8)
    SLEEP()
    JR_EQ8(gModMotor3AMode_8, 1, mod_motor3a_time_on)
    JR_EQ8(gModMotor3AMode_8, 2, mod_motor3a_move_to)
    JR(mod_motor3a_loop)

mod_motor3a_time_on:
    MOVE8_8(0, gModMotor3AReady_8)                                      // Motor 3A no longer ready
    CALL(modMotor3ATimeOn)                                              // Motor 3A time on
    CALL(modMotorReadValue, 2, 101, gModMotor3ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3a_loop)

mod_motor3a_move_to:
    MOVE8_8(0, gModMotor3AReady_8)                                      // Motor 3A no longer ready
    SUB32(gModMotor3ATarget_32, gModMotor3ACurrrent_32, lDelta_32)      // Motor 3A delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor3a_loop)
    CALL(modMotor3AMoveTo, lDelta_32)                                   // Motor 3A move to
    CALL(modMotorReadValue, 2, 101, gModMotor3ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3a_loop)
}

subcall modMotor3AMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor3ASpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor3a_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3a_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor3a_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3a_degrees_positive:

    PORT_CNV_OUTPUT(101, 2, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor3ABrake_8)
mod_motor3a_move_wait_loop:
    OUTPUT_TEST(2, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor3AMode_8, 2, mod_motor3a_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor3a_move_wait_loop)
mod_motor3a_move_done:
    MOVE8_8(0, gModMotor3AMode_8)                                       // Motor 3A mode 0
}

subcall modMotor3ATimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(101, 2, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(2, lBitField_8, gModMotor3ASpeed_8, 0, gModMotor3ATime_32, 0, gModMotor3ABrake_8)
mod_motor3a_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor3AMode_8, 1, mod_motor3a_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor3a_time_wait_loop)
mod_motor3a_time_done:
    MOVE8_8(0, gModMotor3AMode_8)                                       // Motor 3A mode 0
}

//=================================================================================================//
//
// File: vm/modMotor3B.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor3BUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor3b_loop:
    MOVE8_8(1, gModMotor3BReady_8)
    SLEEP()
    JR_EQ8(gModMotor3BMode_8, 1, mod_motor3b_time_on)
    JR_EQ8(gModMotor3BMode_8, 2, mod_motor3b_move_to)
    JR(mod_motor3b_loop)

mod_motor3b_time_on:
    MOVE8_8(0, gModMotor3BReady_8)                                      // Motor 3B no longer ready
    CALL(modMotor3BTimeOn)                                              // Motor 3B time on
    CALL(modMotorReadValue, 2, 102, gModMotor3BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3b_loop)

mod_motor3b_move_to:
    MOVE8_8(0, gModMotor3BReady_8)                                      // Motor 3B no longer ready
    SUB32(gModMotor3BTarget_32, gModMotor3BCurrrent_32, lDelta_32)      // Motor 3B delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor3b_loop)
    CALL(modMotor3BMoveTo, lDelta_32)                                   // Motor 3B move to
    CALL(modMotorReadValue, 2, 102, gModMotor3BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3b_loop)
}

subcall modMotor3BMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor3BSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor3b_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3b_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor3b_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3b_degrees_positive:

    PORT_CNV_OUTPUT(102, 2, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor3BBrake_8)
mod_motor3b_move_wait_loop:
    OUTPUT_TEST(2, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor3BMode_8, 2, mod_motor3b_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor3b_move_wait_loop)
mod_motor3b_move_done:
    MOVE8_8(0, gModMotor3BMode_8)                                       // Motor 3B mode 0
}

subcall modMotor3BTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(102, 2, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(2, lBitField_8, gModMotor3BSpeed_8, 0, gModMotor3BTime_32, 0, gModMotor3BBrake_8)
mod_motor3b_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor3BMode_8, 1, mod_motor3b_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor3b_time_wait_loop)
mod_motor3b_time_done:
    MOVE8_8(0, gModMotor3BMode_8)                                       // Motor 3B mode 0
}

//=================================================================================================//
//
// File: vm/modMotor3C.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor3CUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor3c_loop:
    MOVE8_8(1, gModMotor3CReady_8)
    SLEEP()
    JR_EQ8(gModMotor3CMode_8, 1, mod_motor3c_time_on)
    JR_EQ8(gModMotor3CMode_8, 2, mod_motor3c_move_to)
    JR(mod_motor3c_loop)

mod_motor3c_time_on:
    MOVE8_8(0, gModMotor3CReady_8)                                      // Motor 3C no longer ready
    CALL(modMotor3CTimeOn)                                              // Motor 3C time on
    CALL(modMotorReadValue, 2, 103, gModMotor3CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3c_loop)

mod_motor3c_move_to:
    MOVE8_8(0, gModMotor3CReady_8)                                      // Motor 3C no longer ready
    SUB32(gModMotor3CTarget_32, gModMotor3CCurrrent_32, lDelta_32)      // Motor 3C delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor3c_loop)
    CALL(modMotor3CMoveTo, lDelta_32)                                   // Motor 3C move to
    CALL(modMotorReadValue, 2, 103, gModMotor3CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3c_loop)
}

subcall modMotor3CMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor3CSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor3c_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3c_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor3c_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3c_degrees_positive:

    PORT_CNV_OUTPUT(103, 2, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor3CBrake_8)
mod_motor3c_move_wait_loop:
    OUTPUT_TEST(2, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor3CMode_8, 2, mod_motor3c_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor3c_move_wait_loop)
mod_motor3c_move_done:
    MOVE8_8(0, gModMotor3CMode_8)                                       // Motor 3C mode 0
}

subcall modMotor3CTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(103, 2, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(2, lBitField_8, gModMotor3CSpeed_8, 0, gModMotor3CTime_32, 0, gModMotor3CBrake_8)
mod_motor3c_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor3CMode_8, 1, mod_motor3c_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor3c_time_wait_loop)
mod_motor3c_time_done:
    MOVE8_8(0, gModMotor3CMode_8)                                       // Motor 3C mode 0
}

//=================================================================================================//
//
// File: vm/modMotor3D.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor3DUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor3d_loop:
    MOVE8_8(1, gModMotor3DReady_8)
    SLEEP()
    JR_EQ8(gModMotor3DMode_8, 1, mod_motor3d_time_on)
    JR_EQ8(gModMotor3DMode_8, 2, mod_motor3d_move_to)
    JR(mod_motor3d_loop)

mod_motor3d_time_on:
    MOVE8_8(0, gModMotor3DReady_8)                                      // Motor 3D no longer ready
    CALL(modMotor3DTimeOn)                                              // Motor 3D time on
    CALL(modMotorReadValue, 2, 104, gModMotor3DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3d_loop)

mod_motor3d_move_to:
    MOVE8_8(0, gModMotor3DReady_8)                                      // Motor 3D no longer ready
    SUB32(gModMotor3DTarget_32, gModMotor3DCurrrent_32, lDelta_32)      // Motor 3D delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor3d_loop)
    CALL(modMotor3DMoveTo, lDelta_32)                                   // Motor 3D move to
    CALL(modMotorReadValue, 2, 104, gModMotor3DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor3d_loop)
}

subcall modMotor3DMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor3DSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor3d_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3d_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor3d_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor3d_degrees_positive:

    PORT_CNV_OUTPUT(104, 2, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor3DBrake_8)
mod_motor3d_move_wait_loop:
    OUTPUT_TEST(2, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor3DMode_8, 2, mod_motor3d_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor3d_move_wait_loop)
mod_motor3d_move_done:
    MOVE8_8(0, gModMotor3DMode_8)                                       // Motor 3D mode 0
}

subcall modMotor3DTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(104, 2, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(2, lBitField_8, gModMotor3DSpeed_8, 0, gModMotor3DTime_32, 0, gModMotor3DBrake_8)
mod_motor3d_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor3DMode_8, 1, mod_motor3d_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor3d_time_wait_loop)
mod_motor3d_time_done:
    MOVE8_8(0, gModMotor3DMode_8)                                       // Motor 3D mode 0
}

//=================================================================================================//
//
// File: vm/modMotor4A.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor4AUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor4a_loop:
    MOVE8_8(1, gModMotor4AReady_8)
    SLEEP()
    JR_EQ8(gModMotor4AMode_8, 1, mod_motor4a_time_on)
    JR_EQ8(gModMotor4AMode_8, 2, mod_motor4a_move_to)
    JR(mod_motor4a_loop)

mod_motor4a_time_on:
    MOVE8_8(0, gModMotor4AReady_8)                                      // Motor 4A no longer ready
    CALL(modMotor4ATimeOn)                                              // Motor 4A time on
    CALL(modMotorReadValue, 3, 101, gModMotor4ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4a_loop)

mod_motor4a_move_to:
    MOVE8_8(0, gModMotor4AReady_8)                                      // Motor 4A no longer ready
    SUB32(gModMotor4ATarget_32, gModMotor4ACurrrent_32, lDelta_32)      // Motor 4A delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor4a_loop)
    CALL(modMotor4AMoveTo, lDelta_32)                                   // Motor 4A move to
    CALL(modMotorReadValue, 3, 101, gModMotor4ACurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4a_loop)
}

subcall modMotor4AMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor4ASpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor4a_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4a_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor4a_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4a_degrees_positive:

    PORT_CNV_OUTPUT(101, 3, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor4ABrake_8)
mod_motor4a_move_wait_loop:
    OUTPUT_TEST(3, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor4AMode_8, 2, mod_motor4a_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor4a_move_wait_loop)
mod_motor4a_move_done:
    MOVE8_8(0, gModMotor4AMode_8)                                       // Motor 4A mode 0
}

subcall modMotor4ATimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(101, 3, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(3, lBitField_8, gModMotor4ASpeed_8, 0, gModMotor4ATime_32, 0, gModMotor4ABrake_8)
mod_motor4a_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor4AMode_8, 1, mod_motor4a_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor4a_time_wait_loop)
mod_motor4a_time_done:
    MOVE8_8(0, gModMotor4AMode_8)                                       // Motor 4A mode 0
}

//=================================================================================================//
//
// File: vm/modMotor4B.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor4BUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor4b_loop:
    MOVE8_8(1, gModMotor4BReady_8)
    SLEEP()
    JR_EQ8(gModMotor4BMode_8, 1, mod_motor4b_time_on)
    JR_EQ8(gModMotor4BMode_8, 2, mod_motor4b_move_to)
    JR(mod_motor4b_loop)

mod_motor4b_time_on:
    MOVE8_8(0, gModMotor4BReady_8)                                      // Motor 4B no longer ready
    CALL(modMotor4BTimeOn)                                              // Motor 4B time on
    CALL(modMotorReadValue, 3, 102, gModMotor4BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4b_loop)

mod_motor4b_move_to:
    MOVE8_8(0, gModMotor4BReady_8)                                      // Motor 4B no longer ready
    SUB32(gModMotor4BTarget_32, gModMotor4BCurrrent_32, lDelta_32)      // Motor 4B delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor4b_loop)
    CALL(modMotor4BMoveTo, lDelta_32)                                   // Motor 4B move to
    CALL(modMotorReadValue, 3, 102, gModMotor4BCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4b_loop)
}

subcall modMotor4BMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor4BSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor4b_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4b_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor4b_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4b_degrees_positive:

    PORT_CNV_OUTPUT(102, 3, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor4BBrake_8)
mod_motor4b_move_wait_loop:
    OUTPUT_TEST(3, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor4BMode_8, 2, mod_motor4b_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor4b_move_wait_loop)
mod_motor4b_move_done:
    MOVE8_8(0, gModMotor4BMode_8)                                       // Motor 4B mode 0
}

subcall modMotor4BTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(102, 3, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(3, lBitField_8, gModMotor4BSpeed_8, 0, gModMotor4BTime_32, 0, gModMotor4BBrake_8)
mod_motor4b_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor4BMode_8, 1, mod_motor4b_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor4b_time_wait_loop)
mod_motor4b_time_done:
    MOVE8_8(0, gModMotor4BMode_8)                                       // Motor 4B mode 0
}

//=================================================================================================//
//
// File: vm/modMotor4C.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor4CUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor4c_loop:
    MOVE8_8(1, gModMotor4CReady_8)
    SLEEP()
    JR_EQ8(gModMotor4CMode_8, 1, mod_motor4c_time_on)
    JR_EQ8(gModMotor4CMode_8, 2, mod_motor4c_move_to)
    JR(mod_motor4c_loop)

mod_motor4c_time_on:
    MOVE8_8(0, gModMotor4CReady_8)                                      // Motor 4C no longer ready
    CALL(modMotor4CTimeOn)                                              // Motor 4C time on
    CALL(modMotorReadValue, 3, 103, gModMotor4CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4c_loop)

mod_motor4c_move_to:
    MOVE8_8(0, gModMotor4CReady_8)                                      // Motor 4C no longer ready
    SUB32(gModMotor4CTarget_32, gModMotor4CCurrrent_32, lDelta_32)      // Motor 4C delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor4c_loop)
    CALL(modMotor4CMoveTo, lDelta_32)                                   // Motor 4C move to
    CALL(modMotorReadValue, 3, 103, gModMotor4CCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4c_loop)
}

subcall modMotor4CMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor4CSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor4c_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4c_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor4c_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4c_degrees_positive:

    PORT_CNV_OUTPUT(103, 3, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor4CBrake_8)
mod_motor4c_move_wait_loop:
    OUTPUT_TEST(3, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor4CMode_8, 2, mod_motor4c_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor4c_move_wait_loop)
mod_motor4c_move_done:
    MOVE8_8(0, gModMotor4CMode_8)                                       // Motor 4C mode 0
}

subcall modMotor4CTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(103, 3, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(3, lBitField_8, gModMotor4CSpeed_8, 0, gModMotor4CTime_32, 0, gModMotor4CBrake_8)
mod_motor4c_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor4CMode_8, 1, mod_motor4c_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor4c_time_wait_loop)
mod_motor4c_time_done:
    MOVE8_8(0, gModMotor4CMode_8)                                       // Motor 4C mode 0
}

//=================================================================================================//
//
// File: vm/modMotor4D.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modMotor4DUpdate {
    DATA16 lDelta_32
    DATAF  lDelta_F
    DATA8  lBitField_8
    DATA8  lInverted_8

mod_motor4d_loop:
    MOVE8_8(1, gModMotor4DReady_8)
    SLEEP()
    JR_EQ8(gModMotor4DMode_8, 1, mod_motor4d_time_on)
    JR_EQ8(gModMotor4DMode_8, 2, mod_motor4d_move_to)
    JR(mod_motor4d_loop)

mod_motor4d_time_on:
    MOVE8_8(0, gModMotor4DReady_8)                                      // Motor 4D no longer ready
    CALL(modMotor4DTimeOn)                                              // Motor 4D time on
    CALL(modMotorReadValue, 3, 104, gModMotor4DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4d_loop)

mod_motor4d_move_to:
    MOVE8_8(0, gModMotor4DReady_8)                                      // Motor 4D no longer ready
    SUB32(gModMotor4DTarget_32, gModMotor4DCurrrent_32, lDelta_32)      // Motor 4D delta = target - current
    MOVE32_F(lDelta_32, lDelta_F)
    MATH(ABS, lDelta_F, lDelta_F)
    JR_LTF(lDelta_F, 20, mod_motor4d_loop)
    CALL(modMotor4DMoveTo, lDelta_32)                                   // Motor 4D move to
    CALL(modMotorReadValue, 3, 104, gModMotor4DCurrrent_32)           // Update the current value with the actual value
    JR(mod_motor4d_loop)
}

subcall modMotor4DMoveTo {
    IN_32  pDegrees_32
    DATA8  lBusy_8
    DATA8  lInverted_8
    DATA8  lBitField_8
    DATA8  lSpeed_8

    MOVE8_8(gModMotor4DSpeed_8, lSpeed_8)
    JR_GTEQ8(lSpeed_8, 0, mod_motor4d_speed_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4d_speed_positive:

    JR_GTEQ32(pDegrees_32, 0, mod_motor4d_degrees_positive)
    SUB8(0, lSpeed_8, lSpeed_8)
mod_motor4d_degrees_positive:

    PORT_CNV_OUTPUT(104, 3, lBitField_8, lInverted_8)
    OUTPUT_STEP_SPEED(0, lBitField_8, lSpeed_8, 0, pDegrees_32, 0, gModMotor4DBrake_8)
mod_motor4d_move_wait_loop:
    OUTPUT_TEST(3, lBitField_8, lBusy_8)
    SLEEP()
    JR_NEQ8(gModMotor4DMode_8, 2, mod_motor4d_move_done)                // If no longer mode = 2 then exit...
    JR_NEQ8(lBusy_8, 0, mod_motor4d_move_wait_loop)
mod_motor4d_move_done:
    MOVE8_8(0, gModMotor4DMode_8)                                       // Motor 4D mode 0
}

subcall modMotor4DTimeOn {
    DATA8 lBusy_8
    DATA8 lInverted_8
    DATA8 lBitField_8

    PORT_CNV_OUTPUT(104, 3, lBitField_8, lInverted_8)
    OUTPUT_TIME_SPEED(3, lBitField_8, gModMotor4DSpeed_8, 0, gModMotor4DTime_32, 0, gModMotor4DBrake_8)
mod_motor4d_time_wait_loop:
    OUTPUT_TEST(0, lBitField_8, lBusy_8)
    JR_NEQ8(gModMotor4DMode_8, 1, mod_motor4d_time_done)                // If no longer mode = 1 then exit...
    SLEEP()
    JR_NEQ8(lBusy_8, 0, mod_motor4d_time_wait_loop)
mod_motor4d_time_done:
    MOVE8_8(0, gModMotor4DMode_8)                                       // Motor 4D mode 0
}

//=================================================================================================//
//
// File: vm/modSensorInit.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modSensorInit {
    DATA32 lIndex_32
    DATA8  lValue_8

    ARRAY(CREATE8, 16, gModSensorType_H)                                // Sensor types
    ARRAY(CREATE8, 16, gModSensorMode_H)                                // Sensor modes

    MOVE8_8(0, lIndex_32)
loop:
    MOVE8_8(0, lValue_8)
    ARRAY_WRITE(gModSensorType_H, lIndex_32, lValue_8)
    MOVE8_8(-1, lValue_8)
    ARRAY_WRITE(gModSensorMode_H, lIndex_32, lValue_8)
    ADD8(lIndex_32, 1, lIndex_32)
    JR_LT32(lIndex_32, 16, loop)
}

//=================================================================================================//
//
// File: vm/modSensor.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modSensor {                                                     // 07) SENSOR
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA8  lLayer_8
    DATA8  lPort_8
    DATA8  lType_8
    DATA8  lMode_8
    DATA8  lResult_8
    DATAF  lResult_F
    DATA8  lOffset_8
    DATA32 lOffset_32

    CALL(readMem8, pRegSrc_32, 0, lLayer_8)
    CALL(readMem8, pRegSrc_32, 1, lPort_8)

    MUL8(lLayer_8, 4, lOffset_8)
    ADD8(lOffset_8, lPort_8, lOffset_8)
    MOVE8_32(lOffset_8, lOffset_32)

    JR_EQ8(pModCall_8,  0, mod_sensor_set_type)
    JR_EQ8(pModCall_8,  1, mod_sensor_get_type)
    JR_EQ8(pModCall_8,  2, mod_sensor_set_mode)
    JR_EQ8(pModCall_8,  3, mod_sensor_reset)
    JR_EQ8(pModCall_8,  4, mod_sensor_read)
    RETURN()

mod_sensor_set_type:
    CALL(readMem8, pRegSrc_32, 2, lType_8)
    ARRAY_WRITE(gModSensorType_H, lOffset_32, lType_8)
    RETURN()

mod_sensor_get_type:
    DATA8 lType_8
    DATA8 lMode_8
    INPUT_DEVICE(GET_TYPEMODE, lLayer_8, lPort_8, lType_8, lMode_8)
    ARRAY_WRITE(gModSensorType_H, lOffset_32, lType_8)
    CALL(setRet8AndKeep, lType_8)
    RETURN()

mod_sensor_set_mode:
    CALL(readMem8, pRegSrc_32, 2, lMode_8)
    ARRAY_WRITE(gModSensorMode_H, lOffset_32, lMode_8)
    RETURN()

mod_sensor_reset:
    RETURN()

mod_sensor_read:
    ARRAY_READ(gModSensorType_H, lOffset_32, lType_8)
    JR_EQ8(lType_8,  1, mod_sensor_read_touch)                          // NXT Touch
    JR_EQ8(lType_8, 16, mod_sensor_read_touch)                          // EV3 Touch

    ARRAY_READ(gModSensorMode_H, lOffset_32, lMode_8)
    INPUT_READY(lLayer_8, lPort_8)
    INPUT_READSI(lLayer_8, lPort_8, lType_8, lMode_8, lResult_F)
    JR_NAN(lResult_F, mod_sensor_read_invalid)
    CALL(setRetFAndKeep, lResult_F)
    RETURN()
mod_sensor_read_invalid:
    CALL(setRet8AndKeep, -1)
    RETURN()

mod_sensor_read_touch:
    MOVE8_8(0, lMode_8)
    INPUT_READY(lLayer_8, lPort_8)
    INPUT_READ(lLayer_8, lPort_8, lType_8, lMode_8, lResult_8)
    CALL(setRet8AndKeep, lResult_8)
    RETURN()
}

//=================================================================================================//
//
// File: vm/modFileInit.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modFileInit {
    DATA8  lIndex_8
    DATA32 lOffset_32
    DATA8  lMode_8

    ARRAY(CREATE8, 544, gFiles_H)                                       // 16 * (2 + 32), 16 files: mode, length, name

    MOVE8_8(0, lMode_8)
    MOVE32_32(0, lOffset_32)
    MOVE8_8(0, lIndex_8)
mod_file_init_loop:
    ARRAY_WRITE(gFiles_H, lOffset_32, lMode_8)                          // Set used to 0
    ADD32(lOffset_32, 34, lOffset_32)                                   // lOffset_32 = lOffset_32 + (32 + 3)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, 16, mod_file_init_loop)
}

//=================================================================================================//
//
// File: vm/modFile.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modFile {                                                       // 08) FILE
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA8  lIndex_8
    DATA8  lMode_8
    DATA16 lStringIndex_16
    DATAF  lNumber_F
    DATA32 lFileSize_32

    JR_EQ8(pModCall_8,  0, mod_file_exists)
    JR_EQ8(pModCall_8,  1, mod_file_open)                               // Open read
    JR_EQ8(pModCall_8,  2, mod_file_open)                               // Open write
    JR_EQ8(pModCall_8,  3, mod_file_read_number)
    JR_EQ8(pModCall_8,  4, mod_file_read_string)
    JR_EQ8(pModCall_8,  5, mod_file_write_number)
    JR_EQ8(pModCall_8,  6, mod_file_write_string)
    JR_EQ8(pModCall_8,  7, mod_file_close)
    JR_EQ8(pModCall_8,  8, mod_file_delete)
    JR_EQ8(pModCall_8,  9, mod_file_size)
    RETURN()

mod_file_exists:                                                        // 00) fileExists
    FILE(OPEN_READ, @gString_H, gFile_H, lFileSize_32)
    FILE(CLOSE, gFile_H)
    JR_NEQ32(lFileSize_32, 0, mod_file_exists_found)
    CALL(setRet8AndKeep, 0)
    RETURN()
mod_file_exists_found:
    CALL(setRet8AndKeep, 1)
    RETURN()

mod_file_open:                                                          // 01/02) fileOpen
    JR_EQ8(pModCall_8, 2, mod_file_open_write)
    MOVE8_8(1, lMode_8)                                                 // Set read mode: 1
    JR(mod_file_open_done)
mod_file_open_write:
    MOVE8_8(2, lMode_8)                                                 // Set write mode: 2
mod_file_open_done:
    CALL(modFileGetFreeIndex, lIndex_8)
    JR_EQ8(lIndex_8, -1, mod_file_open_no_more_files)
    CALL(modFileSetMode, lIndex_8, lMode_8)
    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)
    CALL(readString, lStringIndex_16)
    CALL(modFileSetFilename, lIndex_8)
    CALL(setRet8AndKeep, lIndex_8)

    JR_EQ8(pModCall_8, 1, mod_file_open_read)
    FILE(OPEN_WRITE, @gString_H, gFile_H)
    RETURN()
mod_file_open_read:
    FILE(OPEN_READ, @gString_H, gFile_H, lFileSize_32)
    RETURN()
mod_file_open_no_more_files:                                            // There are no more handles available!
    CALL(setRet8AndKeep, -1)
    RETURN()

mod_file_read_number:                                                   // 03) fileReadNumber
    CALL(readMem8, pRegSrc_32, 0, lIndex_8)
    CALL(modFileGetFilename, lIndex_8)
    FILE(GET_HANDLE, @gString_H, gFile_H, 0)                            // 0 = Read, 1 = Write
    FILE(READ_VALUE, gFile_H, 0x03, lNumber_F)
    CALL(setRetFAndKeep, lNumber_F)
    RETURN()

mod_file_read_string:                                                   // 04) fileReadString
    CALL(readMem8, pRegSrc_32, 0, lIndex_8)
    CALL(readMem16, pRegSrc_32, 1, lStringIndex_16)
    CALL(modFileGetFilename, lIndex_8)
    FILE(GET_HANDLE, @gString_H, gFile_H, 0)                            // 0 = Read, 1 = Write
    FILE(READ_TEXT, gFile_H, 0x03, 64, @gString_H)
    CALL(writeString, lStringIndex_16)
    RETURN()

mod_file_write_number:                                                  // 05) fileWriteNumber
    CALL(readMem8, pRegSrc_32, 0, lIndex_8)
    CALL(readMemF, pRegSrc_32, 1, lNumber_F)
    CALL(modFileGetFilename, lIndex_8)
    FILE(GET_HANDLE, @gString_H, gFile_H, 1)                            // 0 = Read, 1 = Write
    FILE(WRITE_VALUE, gFile_H, 0x03, lNumber_F, -16, 4)
    RETURN()

mod_file_write_string:                                                  // 06) fileWriteString
    CALL(readMem8, pRegSrc_32, 0, lIndex_8)
    CALL(modFileGetFilename, lIndex_8)
    FILE(GET_HANDLE, @gString_H, gFile_H, 1)                            // 0 = Read, 1 = Write
    CALL(readMem16, pRegSrc_32, 1, lStringIndex_16)
    CALL(readString, lStringIndex_16)
    FILE(WRITE_TEXT, gFile_H, 0x03, @gString_H)
    RETURN()

mod_file_close:                                                         // 07) fileClose
    CALL(readMem8, pRegSrc_32, 0, lIndex_8)
    CALL(modFileGetMode, lIndex_8, lMode_8)
    CALL(modFileSetMode, lIndex_8, 0)
    JR_EQ8(lMode_8, 1, mode_file_close_read)
    JR_EQ8(lMode_8, 2, mode_file_close_write)
mode_file_close_read:
    FILE(GET_HANDLE, @gString_H, gFile_H, 0)                            // 0 = Read, 1 = Write
    FILE(CLOSE, gFile_H)
    RETURN()
mode_file_close_write:
    FILE(GET_HANDLE, @gString_H, gFile_H, 1)                            // 0 = Read, 1 = Write
    FILE(CLOSE, gFile_H)
    RETURN()

mod_file_delete:                                                        // 08) fileDelete
    FILE(OPEN_READ, @gString_H, gFile_H, lFileSize_32)
    JR_EQ32(lFileSize_32, 0, mod_file_delete_not_found)
    FILE(REMOVE, gFile_H)
mod_file_delete_not_found:
    RETURN()

mod_file_size:                                                          // 09) fileSize
    FILE(OPEN_READ, @gString_H, gFile_H, lFileSize_32)
    FILE(CLOSE, gFile_H)
    CALL(setRet32AndKeep, lFileSize_32)
    RETURN()
}

subcall modFileGetFreeIndex {
    OUT_8  pFreeIndex_8
    DATA32 lOffset_32
    DATA8  lMode_8

    MOVE32_32(0, lOffset_32)
    MOVE8_8(0, pFreeIndex_8)
mod_file_get_free_index_loop:
    ARRAY_READ(gFiles_H, lOffset_32, lMode_8)
    JR_NEQ8(lMode_8, 0, mod_file_get_free_index_used)                   // Mode is not 0, file is used
    RETURN()
mod_file_get_free_index_used:
    ADD32(lOffset_32, 34, lOffset_32)                                   // lOffset_32 = lOffset_32 + (32 + 2)
    ADD8(pFreeIndex_8, 1, pFreeIndex_8)
    JR_LT8(pFreeIndex_8, 16, mod_file_get_free_index_loop)
    MOVE8_8(-1, pFreeIndex_8)
}

subcall modFileGetMode {
    IN_8   pIndex_8
    OUT_8  pMode_8
    DATA32 lOffset_32

    MOVE8_32(pIndex_8, lOffset_32)
    MUL32(lOffset_32, 34, lOffset_32)
    ARRAY_READ(gFiles_H, lOffset_32, pMode_8)
}

subcall modFileSetMode {
    IN_8   pIndex_8
    IN_8   pMode_8
    DATA32 lOffset_32

    MOVE8_32(pIndex_8, lOffset_32)
    MUL32(lOffset_32, 34, lOffset_32)
    ARRAY_WRITE(gFiles_H, lOffset_32, pMode_8)
}

subcall modFileSetFilename {
    IN_8   pIndex_8
    DATA8  lIndex_8
    DATA8  lChar_8
    DATA32 lOffset_32
    DATA8  lStringLength_8
    DATA16 lStringLength_16

    MOVE8_32(pIndex_8, lOffset_32)
    MUL32(lOffset_32, 34, lOffset_32)                                   // lOffset_32 = pIndex_8 * 34
    ADD32(lOffset_32, 1, lOffset_32)                                    // First value is the mode
    STRINGS(GET_SIZE, @gString_H, lStringLength_16)
    MOVE16_8(lStringLength_16, lStringLength_8)
    ARRAY_WRITE(gFiles_H, lOffset_32, lStringLength_8)                  // Save the string length
    MOVE8_8(0, lIndex_8)
mod_file_set_filename_loop:
    ADD32(lOffset_32, 1, lOffset_32)
    READ8(@gString_H, lIndex_8, lChar_8)
    ARRAY_WRITE(gFiles_H, lOffset_32, lChar_8)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lStringLength_8, mod_file_set_filename_loop)
}

subcall modFileGetFilename {
    IN_8   pIndex_8
    DATA8  lIndex_8
    DATA8  lChar_8
    DATA32 lOffset_32
    DATA8  lStringLength_8

    MOVE8_32(pIndex_8, lOffset_32)
    MUL32(lOffset_32, 34, lOffset_32)                                   // lOffset_32 = pIndex_8 * 34
    ADD32(lOffset_32, 1, lOffset_32)                                    // First value is the mode
    ARRAY_READ(gFiles_H, lOffset_32, lStringLength_8)                   // Get the string length
    MOVE8_8(0, lIndex_8)
mod_file_get_filename_loop:
    ADD32(lOffset_32, 1, lOffset_32)
    ARRAY_READ(gFiles_H, lOffset_32, lChar_8)
    WRITE8(lChar_8, lIndex_8, @gString_H)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lStringLength_8, mod_file_get_filename_loop)
    MOVE8_8(0, lChar_8)
    WRITE8(lChar_8, lIndex_8, @gString_H)
}

//=================================================================================================//
//
// File: vm/modBit.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modBit {
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATAF  lValue_F
    DATA32 lX_32
    DATA32 lY_32

    JR_EQ8(pModCall_8, 0, mod_bit_bit_or)
    JR_EQ8(pModCall_8, 1, mod_bit_bit_and)
    JR_EQ8(pModCall_8, 2, mod_bit_to_bit)
    JR_EQ8(pModCall_8, 3, mod_bit_to_bit_not)
    JR_EQ8(pModCall_8, 4, mod_bit_shl)
    JR_EQ8(pModCall_8, 5, mod_bit_shr)
    RETURN()

mod_bit_bit_or:                                                         // 00) bitOr
    CALL(readMem32, pRegSrc_32, 0, lX_32)
    CALL(readMem32, pRegSrc_32, 1, lY_32)
    OR32(lX_32, lY_32, lX_32)
    CALL(setRet32AndKeep, lX_32)
    RETURN()

mod_bit_bit_and:                                                        // 01) bitAnd
    CALL(readMem32, pRegSrc_32, 0, lX_32)
    CALL(readMem32, pRegSrc_32, 1, lY_32)
    AND32(lX_32, lY_32, lX_32)
    CALL(setRet32AndKeep, lX_32)
    RETURN()

mod_bit_to_bit:
    CALL(readMemF, pRegSrc_32, 0, lValue_F)
    JR_EQF(lValue_F, 0, mod_bit_to_bit_0)
    CALL(setRet8AndKeep, 1)
    RETURN()
mod_bit_to_bit_0:
    CALL(setRet8AndKeep, 0)
    RETURN()

mod_bit_to_bit_not:
    CALL(readMemF, pRegSrc_32, 0, lValue_F)
    JR_EQF(lValue_F, 0, mod_bit_to_bit_not_0)
    CALL(setRet8AndKeep, 0)
    RETURN()
mod_bit_to_bit_not_0:
    CALL(setRet8AndKeep, 1)
    RETURN()

mod_bit_shl:
    RETURN()

mod_bit_shr:
    RETURN()
}

//=================================================================================================//
//
// File: vm/modString.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modString {                                                     // 10) STRING
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATA32 lRegDest_32
    DATA32 lRegStack_32
    DATA32 lRegPtr_32
    DATA32 lStringCount_32
    DATA16 lStringIndex_16
    DATA32 lStringIndex_32
    DATA8  lStringLength_8
    DATA16 lNumber_16
    DATAF  lNumber_F

    JR_EQ8(pModCall_8,  0, mod_string_allocate_string)
    JR_EQ8(pModCall_8,  1, mod_string_allocate_global_string)
    JR_EQ8(pModCall_8,  2, mod_string_release_string)
    JR_EQ8(pModCall_8,  3, mod_string_number_to_string)
    JR_EQ8(pModCall_8,  4, mod_string_string_to_number)
    JR_EQ8(pModCall_8,  5, mod_string_index_of)
    JR_EQ8(pModCall_8,  6, mod_string_sub_string)
    JR_EQ8(pModCall_8,  7, mod_string_length)
    JR_EQ8(pModCall_8,  8, mod_string_equal)
    JR_EQ8(pModCall_8,  9, mod_string_upper_case)
    JR_EQ8(pModCall_8, 10, mod_string_lower_case)
    JR_EQ8(pModCall_8, 11, mod_string_get_char_code_at)
    JR_EQ8(pModCall_8, 12, mod_string_set_char_code_at)
    RETURN()

mod_string_allocate_string:                                             // 00) allocateString
    CALL(readMem32, 0, 0, lRegStack_32)                                 // Read stack register from heap offset 0
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3
    ADD32(lRegPtr_32, lRegStack_32, lRegPtr_32)
    JR(mod_string_allocate_global_start)

mod_string_allocate_global_string:                                      // 01) allocateGlobalString
    CALL(readMem32, 0, 0, lRegStack_32)                                 // Read stack register from heap offset 0
    CALL(readMem32, 3, 0, lRegPtr_32)                                   // Read pointer register from heap offset 3

mod_string_allocate_global_start:
    MOVE32_32(0, lStringCount_32)
mod_string_allocate_one_string:                                         // pRegSrc_32 = number of strings
    CALL(writeMem16, lRegPtr_32, 0, gStringCount_16)                    // gHeap_F[lRegPtr_32] = gStringCount_16
    ADD16(gStringCount_16, 1, gStringCount_16)
    ADD32(lRegPtr_32, 1, lRegPtr_32)
    ADD32(lStringCount_32, 1, lStringCount_32)
    JR_LT32(lStringCount_32, pRegSrc_32, mod_string_allocate_one_string)
    RETURN()

mod_string_release_string:                                              // 02) releaseString
    MOVE32_32(0, lStringCount_32)
mod_string_release_one_string:                                          // pRegSrc_32 = number of strings
    CALL(releaseString, lStringIndex_32)
    ADD32(lStringCount_32, 1, lStringCount_32)
    JR_LT32(lStringCount_32, pRegSrc_32, mod_string_release_one_string)
    RETURN()

mod_string_number_to_string:                                            // 03) numberToString
    CALL(readMemF, pRegSrc_32, 0, lNumber_F)
    CALL(readMem16, pRegSrc_32, 1, lStringIndex_16)
    STRINGS(VALUE_TO_STRING, lNumber_F, -16, 4, @gString_H)
    CALL(writeString, lStringIndex_16)
    RETURN()

mod_string_string_to_number:                                            // 04) stringToNumber
    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)
    CALL(readString, lStringIndex_16)
    STRINGS(STRING_TO_VALUE, @gString_H, lNumber_F)
    CALL(setRetFAndKeep, lNumber_F)
    RETURN()

mod_string_index_of:                                                    // 05) indexOf
    CALL(modStringIndexOf, pRegSrc_32)
    RETURN()

mod_string_sub_string:                                                  // 06) subString
    CALL(modStringSub, pRegSrc_32)
    RETURN()

mod_string_length:                                                      // 07) length
    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)
    CALL(readStringLength, lStringIndex_16, lStringLength_8)
    CALL(setRet8AndKeep, lStringLength_8)
    RETURN()

mod_string_equal:                                                       // 08) equal
    CALL(modStringEqual, pRegSrc_32)
    RETURN()

mod_string_upper_case:                                                  // 09) toUpperCase
    CALL(modStringUpperCase, pRegSrc_32)
    RETURN()

mod_string_lower_case:                                                  // 10) toLowerCase
    CALL(modStringLowerCase, pRegSrc_32)
    RETURN()

mod_string_get_char_code_at:                                            // 11) getCharCodeAt
    CALL(modStringGetCharCodeAt, pRegSrc_32)
    RETURN()

mod_string_set_char_code_at:                                            // 12) setCharCodeAt
    CALL(modStringSetCharCodeAt, pRegSrc_32)
    RETURN()
}

subcall modStringUpperCase {
    IN_32  pRegSrc_32
    DATA16 lStringIndex_16
    DATA32 lStringOffset_32
    DATA8  lLength_8
    DATA8  lIndex_8
    DATA8  lChar_8

    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)

    MOVE16_32(lStringIndex_16, lStringOffset_32)
    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = lStringIndex_16 * gStringDataSize_32

    ARRAY_READ(gStrings_H, lStringOffset_32, lLength_8)
    MOVE8_8(0, lIndex_8)
mod_string_loop:
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ARRAY_READ(gStrings_H, lStringOffset_32, lChar_8)
    JR_LT8(lChar_8, 97, mod_string_char_ok)                             // Less than "a" (97)
    JR_GT8(lChar_8, 122, mod_string_char_ok)                            // Less than "z" (172)
    SUB8(lChar_8, 32, lChar_8)
    ARRAY_WRITE(gStrings_H, lStringOffset_32, lChar_8)
mod_string_char_ok:
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lLength_8, mod_string_loop)
}

subcall modStringLowerCase {
    IN_32  pRegSrc_32
    DATA16 lStringIndex_16
    DATA32 lStringOffset_32
    DATA8  lLength_8
    DATA8  lIndex_8
    DATA8  lChar_8

    CALL(readMem16, pRegSrc_32, 0, lStringIndex_16)

    MOVE16_32(lStringIndex_16, lStringOffset_32)
    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = lStringIndex_16 * gStringDataSize_32 + 1

    ARRAY_READ(gStrings_H, lStringOffset_32, lLength_8)
    MOVE8_8(0, lIndex_8)
mod_string_loop:
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ARRAY_READ(gStrings_H, lStringOffset_32, lChar_8)
    JR_LT8(lChar_8, 65, mod_string_char_ok)                             // Less than "A" (65)
    JR_GT8(lChar_8, 90, mod_string_char_ok)                             // Less than "Z" (90)
    ADD8(lChar_8, 32, lChar_8)
    ARRAY_WRITE(gStrings_H, lStringOffset_32, lChar_8)
mod_string_char_ok:
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lLength_8, mod_string_loop)
}

subcall modStringIndexOf {
    IN_32  pRegSrc_32
    DATA16 lStringIndexHaystack_16
    DATA16 lStringIndexNeedle_16
    DATA8  lStringLengthHaystack_8
    DATA8  lStringLengthNeedle_8
    DATA16 lStringLengthNeedle_16
    DATA32 lStringOffsetHaystack_32
    DATA32 lStringOffsetNeedle_32
    DATA32 lStringOffsetC_32
    DATA32 lStringOffsetD_32
    DATA8  lStartIndex_8
    DATA8  lTempIndex_8
    DATA8  lMaxCheckCount_8
    DATA8  lIndexA_8
    DATA16 lIndexB_16
    DATA8  lCharA_8
    DATA8  lCharB_8

    CALL(readMem16, pRegSrc_32, 0, lStringIndexHaystack_16)
    CALL(readMem16, pRegSrc_32, 1, lStringIndexNeedle_16)
    CALL(readMem8,  pRegSrc_32, 2, lStartIndex_8)

    CALL(readStringLength, lStringIndexHaystack_16, lStringLengthHaystack_8)
    CALL(readStringLength, lStringIndexNeedle_16, lStringLengthNeedle_8)

    MOVE8_16(lStringLengthNeedle_8, lStringLengthNeedle_16)

    ADD8(lStartIndex_8, lStringLengthNeedle_8, lTempIndex_8)            // The needle length + startIndex should be less than string length
    JR_LTEQ8(lTempIndex_8, lStringLengthHaystack_8, mod_string_index_needle_less)
    CALL(setRet8AndKeep, -1)                                            // Needle is larger than haystack
    RETURN()
mod_string_index_needle_less:
                                                                        // lMaxCheckCount_8 = haystack - needle length
    SUB8(lStringLengthHaystack_8, lStringLengthNeedle_8, lMaxCheckCount_8)
    ADD8(lMaxCheckCount_8, 1, lMaxCheckCount_8)

    MOVE16_32(lStringIndexHaystack_16, lStringOffsetHaystack_32)
    MUL32(lStringOffsetHaystack_32, gStringDataSize_32, lStringOffsetHaystack_32)
                                                                        // lStringOffsetHaystack_32 = lStringIndexHaystack_16 * gStringDataSize_32 + 1
    ADD32(lStringOffsetHaystack_32, 1, lStringOffsetHaystack_32)

    MOVE16_32(lStringIndexNeedle_16, lStringOffsetNeedle_32)
    MUL32(lStringOffsetNeedle_32, gStringDataSize_32, lStringOffsetNeedle_32)
    ADD32(lStringOffsetNeedle_32, 1, lStringOffsetNeedle_32)            // lStringOffsetHaystack_32 = lStringIndexHaystack_16 * gStringDataSize_32 + 1

    MOVE8_8(0, lIndexA_8)
mod_string_index_loop1:                                                 // Compare from every index between 0..lMaxCheckCount_8

    MOVE8_8(lIndexA_8, lTempIndex_8)
    ADD8(lTempIndex_8, lStartIndex_8, lTempIndex_8)
    MOVE8_32(lTempIndex_8, lStringOffsetC_32)                           // Move the offset in the haystack
    ADD32(lStringOffsetC_32, lStringOffsetHaystack_32, lStringOffsetC_32)
    MOVE32_32(lStringOffsetNeedle_32, lStringOffsetD_32)                // Needle offset starts at 0

    MOVE16_16(0, lIndexB_16)
mod_string_index_loop2:
    ARRAY_READ(gStrings_H, lStringOffsetC_32, lCharA_8)
    ARRAY_READ(gStrings_H, lStringOffsetD_32, lCharB_8)
    JR_NEQ8(lCharA_8, lCharB_8, mod_string_index_different)             // Check if the chars are equal

    ADD32(lStringOffsetC_32, 1, lStringOffsetC_32)
    ADD32(lStringOffsetD_32, 1, lStringOffsetD_32)
    ADD16(lIndexB_16, 1, lIndexB_16)                                    // Characters equal, check next or done...
    JR_LT16(lIndexB_16, lStringLengthNeedle_16, mod_string_index_loop2)

    ADD8(lIndexA_8, lStartIndex_8, lTempIndex_8)
    CALL(setRet8AndKeep, lTempIndex_8)                                  // Found string!
    RETURN()

mod_string_index_different:                                             // Different chars, next index
    ADD8(lIndexA_8, 1, lIndexA_8)
    JR_LT8(lIndexA_8, lMaxCheckCount_8, mod_string_index_loop1)

    CALL(setRet8AndKeep, -1)                                            // Not found!
}

subcall modStringSub {
    IN_32  pRegSrc_32
    DATA32 lStart_32
    DATA8  lLength_8
    DATA8  lEnd_8
    DATA8  lIndex_8
    DATA8  lChar_8
    DATA16 lSrcStringIndex_16
    DATA8  lSrcStringLength_8
    DATA32 lSrcStringOffset_32
    DATA32 lResultStringOffset_32
    DATA32 lResultStringIndex_32

    CALL(readMem16, pRegSrc_32, 0, lSrcStringIndex_16)
    CALL(readMem32, pRegSrc_32, 1, lStart_32)
    CALL(readMem8,  pRegSrc_32, 2, lLength_8)
    CALL(readMem32, pRegSrc_32, 3, lResultStringIndex_32)

    JR_LT8(lStart_32, 0, mod_sub_string_invalid)                        // Exit is start is less than 0

    CALL(readStringLength, lSrcStringIndex_16, lSrcStringLength_8)      // Get the length on input string

                                                                        // lResultStringOffset_32 = lResultStringOffset_32 * gStringDataSize_32
    MUL32(lResultStringIndex_32, gStringDataSize_32, lResultStringOffset_32)

                                                                        // Check if the start is less than the string length
    JR_GT8(lStart_32, lSrcStringLength_8, mod_string_sub_start_too_large)

    ADD8(lStart_32, lLength_8, lEnd_8)
    JR_LT8(lEnd_8, lSrcStringLength_8, mod_string_sub_in_range)
    SUB8(lEnd_8, lSrcStringLength_8, lEnd_8)
    SUB8(lLength_8, lEnd_8, lLength_8)                                  // lLength_8 = lLength_8 - (lEnd_8 - lSrcStringLength_8)
mod_string_sub_in_range:

    MOVE16_32(lSrcStringIndex_16, lSrcStringOffset_32)
    MUL32(lSrcStringOffset_32, gStringDataSize_32, lSrcStringOffset_32)
    ADD32(lSrcStringOffset_32, 1, lSrcStringOffset_32)                  // lSrcStringOffset_32 = lSrcStringIndex_16 * gStringDataSize_32 + 1
    ADD32(lSrcStringOffset_32, lStart_32, lSrcStringOffset_32)

    ARRAY_WRITE(gStrings_H, lResultStringOffset_32, lLength_8)          // Set the result string length
    MOVE8_8(0, lIndex_8)
mod_string_sub_in_loop:
    ADD32(lResultStringOffset_32, 1, lResultStringOffset_32)
    ARRAY_READ(gStrings_H, lSrcStringOffset_32, lChar_8)
    ARRAY_WRITE(gStrings_H, lResultStringOffset_32, lChar_8)
    ADD32(lSrcStringOffset_32, 1, lSrcStringOffset_32)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lLength_8, mod_string_sub_in_loop)
    RETURN()
mod_string_sub_start_too_large:                                         // The start value is larger than the input
    MOVE8_8(0, lChar_8)
    ARRAY_WRITE(gStrings_H, lResultStringOffset_32, lChar_8)            // Set result string length to 0
    RETURN()
mod_sub_string_invalid:
}

subcall modStringEqual {
    IN_32  pRegSrc_32
    DATA16 lStringIndexA_16
    DATA16 lStringIndexB_16
    DATA32 lStringOffsetA_32
    DATA32 lStringOffsetB_32
    DATA8  lLengthA_8
    DATA8  lLengthB_8
    DATA8  lCharA_8
    DATA8  lCharB_8
    DATA8  lIndex_8

    CALL(readMem16, pRegSrc_32, 0, lStringIndexA_16)
    CALL(readMem16, pRegSrc_32, 1, lStringIndexA_16)

    MOVE16_32(lStringIndexA_16, lStringOffsetA_32)
    MUL32(lStringOffsetA_32, gStringDataSize_32, lStringOffsetA_32)

    MOVE16_32(lStringIndexB_16, lStringOffsetB_32)
    MUL32(lStringOffsetB_32, gStringDataSize_32, lStringOffsetB_32)

    ARRAY_READ(gStrings_H, lStringOffsetA_32, lLengthA_8)
    ARRAY_READ(gStrings_H, lStringOffsetB_32, lLengthB_8)
    JR_NEQ8(lLengthA_8, lLengthB_8, mod_string_not_equal)               // Check if the lengths are equal

    MOVE8_8(0, lIndex_8)
mod_string_loop:
    ADD32(lStringOffsetA_32, 1, lStringOffsetA_32)
    ADD32(lStringOffsetB_32, 1, lStringOffsetB_32)
    ARRAY_READ(gStrings_H, lStringOffsetA_32, lCharA_8)
    ARRAY_READ(gStrings_H, lStringOffsetB_32, lCharB_8)
    JR_NEQ8(lCharA_8, lCharB_8, mod_string_not_equal)
    ADD8(lIndex_8, 1, lIndex_8)
    JR_LT8(lIndex_8, lLengthA_8, mod_string_loop)                       // Loop over the length of the strings
    CALL(setRet8AndKeep, 1)                                             // No differences found
    RETURN()
mod_string_not_equal:
    CALL(setRet8AndKeep, 0)
}

subcall modStringGetCharCodeAt {
    IN_32  pRegSrc_32
    DATA32 lStringOffset_32
    DATA8  lLength_8
    DATA8  lIndex_8
    DATA16 lIndex_16
    DATA32 lIndex_32
    DATA8  lChar_8

    CALL(readMem32, pRegSrc_32, 0, lStringOffset_32)
    CALL(readMem16, pRegSrc_32, 1, lIndex_16)

    JR_LT16(lIndex_16, 0, mod_string_get_char_code_at_index_invalid)    // Index less than 0

    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = lStringIndex_16 * gStringDataSize_32

    ARRAY_READ(gStrings_H, lStringOffset_32, lLength_8)
    MOVE16_8(lIndex_16, lIndex_8)                                       // Exit if index is larger than length
    JR_GTEQ8(lIndex_8, lLength_8, mod_string_get_char_code_at_index_invalid)

    MOVE16_32(lIndex_16, lIndex_32)
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ADD32(lStringOffset_32, lIndex_32, lStringOffset_32)
    ARRAY_READ(gStrings_H, lStringOffset_32, lChar_8)                   // Read the char code
    CALL(setRet8AndKeep, lChar_8)

    RETURN()
mod_string_get_char_code_at_index_invalid:
}

subcall modStringSetCharCodeAt {
    IN_32  pRegSrc_32
    DATA32 lStringOffset_32
    DATA8  lLength_8
    DATA8  lIndex_8
    DATA16 lIndex_16
    DATA32 lIndex_32
    DATA8  lChar_8

    CALL(readMem32, pRegSrc_32, 0, lStringOffset_32)
    CALL(readMem16, pRegSrc_32, 1, lIndex_16)
    CALL(readMem8,  pRegSrc_32, 2, lChar_8)

    JR_LT16(lIndex_16, 0, mod_string_set_char_code_at_index_invalid)    // Index less than 0

    MUL32(lStringOffset_32, gStringDataSize_32, lStringOffset_32)       // lStringOffset_32 = lStringIndex_32 * gStringDataSize_32

    ARRAY_READ(gStrings_H, lStringOffset_32, lLength_8)
    MOVE16_8(lIndex_16, lIndex_8)                                       // Exit if index is larger than length
    JR_GTEQ8(lIndex_8, lLength_8, mod_string_set_char_code_at_index_invalid)

    MOVE16_32(lIndex_16, lIndex_32)
    ADD32(lStringOffset_32, lIndex_32, lStringOffset_32)
    ADD32(lStringOffset_32, 1, lStringOffset_32)
    ARRAY_WRITE(gStrings_H, lStringOffset_32, lChar_8)                  // Read the char code

    RETURN()
mod_string_set_char_code_at_index_invalid:
}

//=================================================================================================//
//
// File: vm/modSystem.lms
//
//=================================================================================================//

//=================================================================================================//
//
// Wheel VM
//
// Copyright Arno van der Vegt 2019
// license: https://arnovandervegt.github.io/wheel/license.txt
//
//=================================================================================================//
subcall modSystem {                                                     // 09) SYSTEM
    IN_8   pModCall_8
    IN_32  pRegSrc_32
    DATAF  lVoltage_F
    DATAF  lCurrent_F
    DATA8  lLevel_8
    DATA8  lVolume_8
    DATA8  lMinutes_8
    DATA8  lMaxLength_8
    DATA16 lBrickname_16
    HANDLE lBrickname_H
    DATA32 lTotal_32
    DATA32 lFree_32

    JR_EQ8(pModCall_8,  0, mod_system_battery_voltage)
    JR_EQ8(pModCall_8,  1, mod_system_battery_current)
    JR_EQ8(pModCall_8,  2, mod_system_battery_level)
    JR_EQ8(pModCall_8,  3, mod_system_get_volume)
    JR_EQ8(pModCall_8,  4, mod_system_set_volume)
    JR_EQ8(pModCall_8,  5, mod_system_get_power_off_minutes)
    JR_EQ8(pModCall_8,  6, mod_system_set_power_off_minutes)
    JR_EQ8(pModCall_8,  7, mod_system_get_brickname)
    JR_EQ8(pModCall_8,  8, mod_system_set_brickname)
    JR_EQ8(pModCall_8,  9, mod_system_memory_total)
    JR_EQ8(pModCall_8, 10, mod_system_memory_free)
    RETURN()

mod_system_battery_voltage:                                             // 00) getBatteryVoltage
    UI_READ(GET_VBATT, lVoltage_F)
    CALL(setRetFAndKeep, lVoltage_F)
    RETURN()

mod_system_battery_current:                                             // 01) getBatteryCurrent
    UI_READ(GET_IBATT, lCurrent_F)
    CALL(setRetFAndKeep, lCurrent_F)
    RETURN()

mod_system_battery_level:                                               // 02) getBatteryLevel
    UI_READ(GET_LBATT, lLevel_8)
    CALL(setRet8AndKeep, lLevel_8)
    RETURN()

mod_system_get_volume:                                                  // 03) getVolume
    INFO(GET_VOLUME, lVolume_8)
    CALL(setRet8AndKeep, lVolume_8)
    RETURN()

mod_system_set_volume:                                                  // 04) setVolume
    CALL(readMem8, pRegSrc_32, 0, lVolume_8)
    INFO(SET_VOLUME, lVolume_8)
    RETURN()

mod_system_get_power_off_minutes:                                       // 05) getPowerOffMinutes
    INFO(GET_MINUTES, lMinutes_8)
    CALL(setRet8AndKeep, lMinutes_8)
    RETURN()

mod_system_set_power_off_minutes:                                       // 06) setPowerOffMinutes
    CALL(readMem8, pRegSrc_32, 0, lMinutes_8)
    INFO(SET_MINUTES, lMinutes_8)
    RETURN()

mod_system_get_brickname:                                               // 07) getBrickName
    CALL(readMem16, pRegSrc_32, 0, lBrickname_16)
    ARRAY(CREATE8, 24, lBrickname_H)
    MOVE8_8(24, lMaxLength_8)
    COM_GET(GET_BRICKNAME, lMaxLength_8, lBrickname_H)
    ARRAY(DELETE, lBrickname_H)
    RETURN()

mod_system_set_brickname:                                               // 08) setBrickName
    CALL(readMem16, pRegSrc_32, 0, lBrickname_16)
    CALL(readString, lBrickname_16)
    COM_SET(SET_BRICKNAME, gString_H)
    ARRAY(DELETE, lBrickname_H)
    RETURN()

mod_system_memory_total:                                                // 09) getMemoryTotal
    MEMORY_USAGE(lTotal_32, lFree_32)
    CALL(setRet32AndKeep, lTotal_32)
    RETURN()

mod_system_memory_free:                                                 // 10) getMemoryFree
    MEMORY_USAGE(lTotal_32, lFree_32)
    CALL(setRet32AndKeep, lFree_32)
    RETURN()
}